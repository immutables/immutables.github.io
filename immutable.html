<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css"-->
  <link rel="stylesheet" href="/gfx/bootstrap.min.css">
  <link rel="stylesheet" href="/gfx/main.css">
  <link rel="stylesheet" href="/gfx/code.css">
  <title>Immutable objects</title>
</head>
<body class="page">
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-PMJSKV"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-PMJSKV');</script>
<!-- End Google Tag Manager -->

<header>
  <div class="container">
    <a href="/">Immutables</a> &larr;

    <h1>Immutable objects <iframe src="https://ghbtns.com/github-btn.html?user=immutables&repo=immutables&type=star&count=true&size=large" frameborder="0" scrolling="0" width="160px" height="30px"></iframe>
</h1>
  </div>
</header>
<aside id="toc"></aside>
<section class="documentation">
  <h2>Overview</h2>

<p>To reap the benefits of immutability in Java, we created an annotation processor
to easily create simple and consistent value objects. You can think of it as
<a href="https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">Guava&#39;s Immutable Collections</a> but for regular objects.</p>

<p>The core of <em>Immutables</em> is modelling. Good modelling is at the heart of creating good applications and
services, and of good design in general. We feel proud to fill a gap in the area of modelling in the Java programming language, where conventional JavaBeans are insufficient.</p>

<ul>
<li>Immutable objects are constructed once, in a consistent state, and can be safely shared

<ul>
<li>Will fail if mandatory attributes are missing</li>
<li>Cannot be sneakily modified when passed to other code</li>
</ul></li>
<li>Immutable objects are naturally thread-safe and can therefore be safely shared among threads

<ul>
<li>No excessive copying</li>
<li>No excessive synchronization</li>
</ul></li>
<li>Object definitions are pleasant to write and read

<ul>
<li>No boilerplate setter and getters</li>
<li>No ugly IDE-generated <code>hashCode</code>, <code>equals</code> and <code>toString</code> methods that end up being stored in source control.</li>
</ul></li>
</ul>

<p><a href="/getstarted.html">Get started!</a> Create an <em>abstract value class</em> and then add annotation to generate an <em>immutable implementation class</em>!</p>

<p>See <a href="/generated.html">sample generated code</a> for an example of the code generated by the processor,
or jump straight to the <a href="/immutable.html#features">features</a>!</p>

<h2>Concepts</h2>

<p><a name="abstract-value"></a></p>

<h3>Abstract value type</h3>

<p>An Abstract value type is a manually-written non-final (usually abstract) class or
interface (or even annotation type) that defines the value type and is annotated with the
<code>org.immutables.value.Value.Immutable</code> annotation.
It may contain <a href="#attributes">attributes</a> and other metadata, as well as regular Java methods (and fields, if necessary).
It is strongly recommended that abstract value types not introduce visible mutable state.
Abstract value types are used as the source model for generated code. <a href="/getstarted.html">Get started!</a>.</p>

<p><a name="attributes"></a></p>

<h3>Attributes</h3>

<p>An attribute holds a value that cannot be changed after the owning object is created.
The name &quot;attribute&quot; is used to intentionally distinguish the concept from &quot;fields&quot; or JavaBean &quot;properties&quot;, and to imply a similarity with Java annotation attributes.
It is defined by an accessor method: A zero argument, non-<code>void</code>-returning Java method.
No annotations are required on abstract accessor methods in order for them to become attributes. However, some attributes
such as those with <a href="#default-attribute">default values</a>
are non-<code>abstract</code> methods that have bodies that compute values.
Such accessors therefore require special annotations to distinguish them from regular methods.</p>

<h3>Immutable implementation class</h3>

<p>A <a href="/generated.html">Generated</a> <code>final</code> class that extends a manually-written <a href="#abstract-value">abstract value type</a>
and implements all declared accessor methods as well as supporting fields, methods, constructors, and a builder class.
An immutable implementation class implements abstract attribute accessors
for scalar primitive and object reference types, with special support provided for <a href="#collection">collection attributes</a>
and other types.
<code>java.lang.Object</code>&#39;s <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods are overridden and fully dependent on attribute values
rather than on object identity.
Immutable implementation classes are the primary (but not the only) source code artifacts
generated by the <em>Immutables</em> annotation processor.</p>

<p><a name="features"></a></p>

<h2>Features</h2>

<h3>Value</h3>

<p>The annotation processor works by using annotated abstract value types as a model to generate immutable implementations.
A generated implementation extends or implements an abstract value type. Classes don&#39;t have to be abstract if they don&#39;t define abstract accessor methods.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">interface</span> <span class="nc">ValueInterface</span> <span class="o">{}</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">class</span> <span class="nc">ValueClass</span> <span class="o">{}</span>

<span class="nd">@Value.Immutable</span>
<span class="nd">@interface</span> <span class="n">ValueAnnotation</span> <span class="o">{}</span>

<span class="o">...</span>

<span class="n">ValueInterface</span> <span class="n">valueInterface</span> <span class="o">=</span> <span class="n">ImmutableValueInterface</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

<span class="n">ValueClass</span> <span class="n">valueClass</span> <span class="o">=</span> <span class="n">ImmutableValueClass</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

<span class="n">ValueAnnotation</span> <span class="n">valueAnnotation</span> <span class="o">=</span> <span class="n">ImmutableValueAnnotation</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p><em>You can customize generated class names to have other prefixes than <code>Immutable*</code> or to have no prefix at all. See <a href="/style.html">styles</a></em>.</p>

<p>Nested abstract value types should be declared <code>static</code> if declared as inner classes (interfaces
and annotations are implicitly <code>static</code> if nested).</p>

<p><a name="include"></a></p>

<p>You are not limited to using classes that you control. You can generate immutable implementation
classes from the abstract types in other packages.</p>

<p>The <code>@Value.Include</code> annotation can be used on types and packages. This is most useful when you
want to generate implementations of annotations to use with DI libraries such as <em>Guice</em>. Inclusion
can be used in combination with <a href="/style.html#nesting"><code>@Value.Enclosing</code></a></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kn">package</span> <span class="nn">my.package</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Retention</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.RetentionPolicy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.immutables.value.Value</span><span class="o">;</span>

<span class="nd">@Value.Include</span><span class="o">({</span> <span class="n">Retention</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span>
<span class="kd">interface</span> <span class="nc">IncludedAnnotations</span> <span class="o">{}</span>
<span class="o">...</span>

<span class="n">ImmutableRetention</span><span class="o">.</span><span class="na">build</span><span class="o">()</span>
    <span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">CLASS</span><span class="o">);</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p><a name="builder"></a></p>

<h3>Builder</h3>

<p>By default, builders are generated for each immutable implementation class.
Builders enable expressive construction of objects using named attribute initializers.
Generally, builders compensate for the lack of named and optional constructor arguments in the Java language.</p>

<ul>
<li>To create a builder, invoke the static <code>builder()</code> method on a generated immutable implementation class</li>
<li>Invoke attribute initializer methods to set attributes</li>
<li>Call <code>build()</code> method to construct immutable instances after attributes are initialized</li>
</ul>

<p>The <code>build()</code> method will fail if any mandatory attribute is omitted. Efficient bit masks are used
internally to track which attributes are initialized!</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="c1">// builder methods illustrated</span>
<span class="n">ImmutableValue</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">foo</span><span class="o">(</span><span class="mi">1442</span><span class="o">)</span>
    <span class="o">.</span><span class="na">bar</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addBuz</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addBuz</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">,</span> <span class="s">&quot;2&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addAllBuz</span><span class="o">(</span><span class="n">iterable</span><span class="o">)</span>
    <span class="o">.</span><span class="na">putQux</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p><em>You can customize initialization methods to have prefixes like <code>set</code> or <code>with</code>, have builders created by constructor, have <code>create</code> methods, etc. See <a href="/style.html">styles</a></em>.</p>

<p>By default, builders have a method named <code>from</code>. The <code>from</code> method allows for &quot;editing&quot;
operations on immutable values by initializing the builder with attribute values taken
from an existing immutable object. This could be used to prevent structural sharing as happens with
<a href="#copy-methods">copy-methods</a>, or to accumulate collection elements from attributes of multiple
values.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">ImmutableValue</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">otherValue</span><span class="o">)</span> <span class="c1">// merges attribute value into builder</span>
    <span class="o">.</span><span class="na">addBuz</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p>The <code>from</code> method on builders is a much more sound and powerful alternative than having <code>toBuilder()</code> (or alike) on immutable values. For <a href="#strict-builder">strict builders</a>, <code>from</code>
methods are not generated as they&#39;re prone to errors. If value object inherits abstract accessor definitions from super-types, than it would be possible to copy from super-type instance (of any implementation type) those attributes which are applicable. Generated <code>from</code> method will have overloads for each super-type from which we can get attribute values we inherit. Just to note: types parameterized with generics and accessors with covariant return type overrides will be excluded from such &quot;from super-type&quot; initialization.</p>

<p>If a particular builder has become redundant due to the presence of a <a href="#constructor">constructor</a>,
generation of the builder can be disabled using the <code>@Value.Immutable(builder = false)</code>
annotation parameter.</p>

<p>For advanced use cases, it may be desirable to have builders that produce different
types of objects but conform to the same interface, akin to the original
<a href="http://en.wikipedia.org/wiki/Builder_pattern">Builder pattern</a>. This is achievable by
declaring a static nested class named &quot;Builder&quot; which will be extended by the generated builder.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">interface</span> <span class="nc">Vehicle</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">VehicleBuilder</span> <span class="o">{</span>
  <span class="c1">// Generated builders will implement this method</span>
  <span class="c1">// It is compatible with signature of generated builder methods where</span>
  <span class="c1">// return type is narrowed to Scooter or Automobile</span>
  <span class="n">Vehicle</span> <span class="nf">build</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scooter</span> <span class="kd">implements</span> <span class="n">Vehicle</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="kd">implements</span> <span class="n">VehicleBuilder</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Automobile</span> <span class="kd">implements</span> <span class="n">Vehicle</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="kd">implements</span> <span class="n">VehicleBuilder</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Builders</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">buildIt</span><span class="o">(</span><span class="n">VehicleBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Vehicle</span> <span class="n">vehicle</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">use</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">buildIt</span><span class="o">(</span><span class="n">ImmutableScooter</span><span class="o">.</span><span class="na">builder</span><span class="o">());</span>
    <span class="n">buildIt</span><span class="o">(</span><span class="n">ImmutableAutomobile</span><span class="o">.</span><span class="na">builder</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>An explicitly declared abstract &quot;Builder&quot; could specify all needed <code>extends</code> or <code>implements</code>
declarations in addition to having convenience methods that will show up on the generated builder.
However, special care should be taken in order to maintain the structural compatibility of
declared builder super-types and generated builders to prevent compile-time type errors from
appearing in the generated code.</p>

<p>Using &quot;forwarding&quot; factory methods and abstract builders, it is possible to hide the generated
implementation type and its builder from the API. See this <a href="#hide-implementation">example</a>.</p>

<p>Another structural customization for builders involves having a private immutable implementation
class, hidden inside the builder, which is then generated as a standalone top-level builder
class in the same package.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="nd">@Value.Style</span><span class="o">(</span><span class="n">visibility</span> <span class="o">=</span> <span class="n">ImplementationVisibility</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="n">String</span> <span class="nf">getName</span><span class="o">();</span>
  <span class="n">String</span> <span class="nf">getAddress</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PersonBuilder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;Jim Boe&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">address</span><span class="o">(</span><span class="s">&quot;P.O. box 0001, Lexington, KY&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p><a name="extending-builder"></a>
From version <code>2.0.17</code> onwards, it is possible to extend a [yet-to-be] generated builder to code
in the following style:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Style</span><span class="o">(</span><span class="n">visibility</span> <span class="o">=</span> <span class="n">ImplementationVisibility</span><span class="o">.</span><span class="na">PACKAGE</span><span class="o">,</span> <span class="n">overshadowImplementation</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="c1">//...</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Person</span> <span class="o">{</span>
  <span class="n">String</span> <span class="nf">name</span><span class="o">();</span>
  <span class="n">String</span> <span class="nf">address</span><span class="o">();</span>
  <span class="c1">// static inner class Builder extends generated or yet to be generated Builder</span>
  <span class="kd">class</span> <span class="nc">Builder</span> <span class="kd">extends</span> <span class="n">ImmutablePerson</span><span class="o">.</span><span class="na">Builder</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;Jim Boe&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">address</span><span class="o">(</span><span class="s">&quot;P.O. box 0000, Lexington, KY&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p>While <code>ImmutablePerson</code> (and <code>ImmutablePerson.Builder</code> consequently) is not visible outside of package, <code>Person.Builder</code> inherits and exposes all public methods defined on <code>ImmutablePerson.Builder</code>.
The <code>overshadowImplementation = true</code> style attribute makes sure that <code>build()</code> will be declared to return abstract value type <code>Person</code>, not the implementation <code>ImmutablePerson</code>, following metaphor: implementation type will be &quot;overshadowed&quot; by abstract value type.
The interesting fact is that the calling bytecode references only <code>Person.Builder</code> and not <code>ImmutablePerson.Builder</code>. From the above example: <code>INVOKEVIRTUAL</code> will target <code>Person.Builder.name</code>, <code>Person.Builder.address</code> and <code>Person.Builder.build</code> methods. Essentially, a generated class becomes implementation detail without much boilerplate which is needed to fully <a href="#hide-implementation">hide implementation</a> behind user-written code.</p>

<p>For other structural and naming style customizations, see the <a href="/style.html">style guide</a>.</p>

<p><a name="strict-builder"></a></p>

<h3>Strict Builder</h3>

<p>By setting the <code>strictBuilder</code> style parameter (<code>@Value.Style(strictBuilder = true, ...)</code>),
you can instruct generated builders to operate in <em>strict mode</em>: only forward-only
initialization is possible. In other words, only
additive operations are available on collection attributes, and regular
attributes can be set only once. Strict builders enable early error detection
during initialization, such as misspellings or copy-paste leftovers. This makes
builders even more similar to object literal expressions. Strict mode is off
by default: regular builders are generated in a way that allows the resetting
of previously set values.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="nd">@Value.Style</span><span class="o">(</span><span class="n">strictBuilder</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">interface</span> <span class="nc">Aar</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">a</span><span class="o">();</span>
  <span class="n">Integer</span> <span class="nf">b</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">ImmutableAar</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">a</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
    <span class="o">.</span><span class="na">b</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">b</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// IllegalStateException will be thrown here, &#39;b&#39; cannot be reinitialized</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p>No methods to reset collections are generated on strict builders. Additionally, no <code>from</code> method is generated. Those methods would be error-inducing in strict mode.</p>

<p>Note that it is not recommended to use <code>@Value.Style</code> directly on abstract value type; use it directly only during experimentation.
The preferred method to use <code>Style</code> annotations is to create meta-annotations as described in the <a href="/style.html">style guide</a>.</p>

<h3>Staged builder</h3>

<p>The experimental new feature (since 2.3.2) allows you to enable generation of &quot;staged builders&quot; (aka &quot;telescopic builders&quot;). The mode is activated using <code>@Value.Style(stagedBuilder = true)</code> style attribute. A staged builder is a compile-time safe way to ensure that all required attributes are set. The API, composed of stage interfaces, forces initialization of mandatory attributes in stages, one by one, guiding via code-completion and making it impossible to even call <code>build()</code> before all are set. This guarantees that final <code>build()</code> call will not throw <code>IllegalStateException</code> for missing attributes. All remaining optional, nullable and collection attributes can be initialized on a final stage in any order. An addition, removal or change of the source order of the required attributes will cause compilation error for all builder usages and have to be corrected.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Style</span><span class="o">(</span><span class="n">stagedBuilder</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">name</span><span class="o">();</span>
    <span class="kt">int</span> <span class="nf">age</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="nf">isEmployed</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="n">ImmutablePerson</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;Billy Bounce&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">age</span><span class="o">(</span><span class="mi">33</span><span class="o">)</span>
    <span class="o">.</span><span class="na">isEmployed</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">...</span>
<span class="c1">// under the hood</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ImmutablePerson</span> <span class="kd">implements</span> <span class="n">Person</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">NameBuildStage</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NameBuildStage</span> <span class="o">{</span> <span class="n">AgeBuildStage</span> <span class="nf">name</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AgeBuildStage</span> <span class="o">{</span> <span class="n">IsEmployedBuildStage</span> <span class="nf">age</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IsEmployedBuildStage</span> <span class="o">{</span> <span class="n">BuildFinal</span> <span class="nf">isEmployed</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isEmployed</span><span class="o">);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BuildFinal</span> <span class="o">{</span> <span class="n">ImmutablePerson</span> <span class="nf">build</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>The price to pay for the additional compile-time safety is the increased count of java interfaces, generated per each required attribute. If staged builders are used extensively, this may lead to the increased memory/disc footprint and can affect class-loading time.</p>

<p>The staged builder mode also implies <a href="#strict-builder">strict builder</a> mode.</p>

<p><a name="constructor"></a></p>

<h3>Constructor method</h3>

<p>As an alternative to builders, it is possible to provide concise &quot;constructor&quot; factory methods.
A &quot;constructor&quot; will be available as a <code>static</code> method named <code>of</code>, on generated immutable implementation classes.</p>

<p>In order to generate a constructor method, certain attributes have to be annotated
with <code>org.immutables.value.Value.Parameter</code> annotations.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">HostWithPort</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">String</span> <span class="nf">hostname</span><span class="o">();</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">port</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="n">HostWithPort</span> <span class="n">hostWithPort</span> <span class="o">=</span> <span class="n">ImmutableHostWithPort</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">8081</span><span class="o">);</span>

<span class="kt">boolean</span> <span class="n">willBeTrue</span> <span class="o">=</span> <span class="n">hostWithPort</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span>
    <span class="n">ImmutableHostWithPort</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">hostname</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">port</span><span class="o">(</span><span class="mi">8081</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">());</span>
</code></pre></div>
<p>You can optionally specify the ordering of parameters using <code>order</code> annotation attributes,
to ensure that the order of constructor parameters does not differ between Java compilers
(Java compilers do not necessarily preserve the order of declarations). Source ordering currently
works for <code>javac</code> and Eclipse JDT compilers.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">HostWithPort</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span><span class="o">(</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">port</span><span class="o">();</span>
  <span class="nd">@Value.Parameter</span><span class="o">(</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">String</span> <span class="nf">hostname</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="n">HostWithPort</span> <span class="n">hostWithPort</span> <span class="o">=</span> <span class="n">ImmutableHostWithPort</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">8081</span><span class="o">);</span>
</code></pre></div>
<p>If you want to automatically turn all attributes into parameters to generate constructor, you could use styles for that, see <a href="#tuples">tuple style</a> pattern.</p>

<h4>Plain public constructor</h4>

<p>If there&#39;s a need for plain public constructor instead of the factory method we can achieve it using <a href="style.html">styles</a> by &quot;renaming&quot; <code>of</code> method to <code>new</code>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Style</span><span class="o">(</span>
  <span class="n">of</span> <span class="o">=</span> <span class="s">&quot;new&quot;</span><span class="o">,</span> <span class="c1">// renames &quot;of&quot; method to &quot;new&quot;, which is interpreted as plain constructor</span>
  <span class="n">allParameters</span> <span class="o">=</span> <span class="kc">true</span> <span class="c1">// unrelated to the line above: every attribute becomes parameter</span>
  <span class="c1">// reminder: don&#39;t get used to inline styles, read style guide!</span>
<span class="o">)</span>
<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HostWithPort</span> <span class="o">{</span>
  <span class="n">String</span> <span class="nf">host</span><span class="o">();</span>
  <span class="kt">int</span> <span class="nf">port</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">HostWithPort</span> <span class="n">hostWithPort</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ImmutableHostWithPort</span><span class="o">(</span><span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="mi">8081</span><span class="o">);</span>
</code></pre></div>
<p><strong>Things to be aware of</strong></p>

<ul>
<li>If not all mandatory attributes are marked as <code>@Value.Parameter</code>

<ul>
<li>Compilation error: could not generate default value for mandatory field.</li>
</ul></li>
</ul>

<p><a name="collection"></a></p>

<h3>Array, Collection and Map attributes</h3>

<p>Following collection types enjoy built-in support for convenient usage:</p>

<ul>
<li><p><code>T[]</code></p></li>
<li><p><code>java.util.List&lt;T&gt;</code></p></li>
<li><p><code>java.util.Set&lt;T&gt;</code></p></li>
<li><p><code>java.util.Map&lt;K, V&gt;</code></p></li>
<li><p><code>com.google.common.collect.Multiset&lt;T&gt;</code></p></li>
<li><p><code>com.google.common.collect.Multimap&lt;K, V&gt;</code> (<code>ListMultimap</code>, <code>SetMultimap</code>)</p></li>
<li><p><code>com.google.common.collect.BiMap&lt;K, V&gt;</code></p></li>
<li><p><code>com.google.common.collect.Immutable*</code> variants for collections above</p></li>
</ul>

<p>Array attributes are cloned for safety (due to the mutable nature of Java arrays).
Collection attributes are backed by Guava immutable collections if Guava is available on the classpath.
Otherwise, they are safely copied and wrapped in unmodifiable collection classes from the standard JDK.</p>

<p><code>java.util.Set</code> and <code>java.util.Map</code> with <code>enum</code> keys are backed by efficient <code>EnumSet</code> and <code>EnumMap</code> implementations.</p>

<p><a name="natural-reverse"></a>
Ordered maps and sets are recognized for natural and reverse natural ordering
using <code>@Value.NaturalOrder</code> and <code>@Value.ReverseOrder</code> annotations, respectively.</p>

<ul>
<li><p><code>java.util.SortedSet&lt;T&gt;</code></p></li>
<li><p><code>java.util.NavigableSet&lt;T&gt;</code></p></li>
<li><p><code>java.util.SortedMap&lt;K, V&gt;</code></p></li>
<li><p><code>java.util.NavigableMap&lt;K, V&gt;</code></p></li>
</ul>

<p>Without ordering annotations, ordered sets and maps attributes will be generated as regular
attributes to support construction with custom comparators, etc.</p>

<p>All mentioned above collection types could be also declared as Guava&#39;s immutable collections
<code>com.google.common.collect.Immutable*</code>. Please note that other collection <em>implementations</em>
such as <code>java.util.ArrayList</code> will not be recognized as special collection attributes.</p>

<p>When building using builders, the contents of collection attributes can be left unspecified.
It is possible to verify, for example, that they contain a required number of items using <a href="#check-method">Precondition check methods</a>.</p>

<p><a href="#builder">Builders</a> have special methods to initialize collection attributes:</p>

<ul>
<li><p>For an array attribute named <code>foo</code>, where elements are of type <code>T</code></p>

<ul>
<li><code>foo(T...)</code></li>
</ul></li>
<li><p>For a <code>List</code>, <code>Set</code>, or <code>Multiset</code> attribute named <code>foo</code>, where elements are of type <code>T</code></p>

<ul>
<li><code>foo(Iterable&lt;? extends T&gt;)</code> &mdash; not available in <a href="#strict-builder">strict</a> mode</li>
<li><code>addFoo(T)</code></li>
<li><code>addFoo(T...)</code></li>
<li><code>addAllFoo(Iterable&lt;? extends T&gt;)</code></li>
</ul></li>
<li><p>For a <code>Map</code> or <code>BiMap</code> attribute named <code>bar</code>, where keys are of type <code>K</code> and values of type <code>V</code></p>

<ul>
<li><code>bar(Map&lt;? extends K, ? extends V&gt;)</code> &mdash; not available in <a href="#strict-builder">strict</a> mode</li>
<li><code>putBar(K, V)</code></li>
<li><code>putBar(Map.Entry&lt;? extends K, ? extends V&gt;)</code></li>
<li><code>putAllBar(Map&lt;? extends K, ? extends V&gt;)</code></li>
</ul></li>
<li><p>For a <code>Multimap</code> attribute named <code>bar</code></p>

<ul>
<li><code>bar(Multimap&lt;? extends K, ? extends V&gt;)</code> &mdash; not available in <a href="#strict-builder">strict</a> mode</li>
<li><code>putBar(K, V)</code></li>
<li><code>putBar(Map.Entry&lt;? extends K, ? extends V&gt;)</code></li>
<li><code>putBar(K, ...V)</code></li>
<li><code>putAllBar(K, Iterable&lt;V&gt;)</code></li>
<li><code>putAllBar(Multimap&lt;? extends K, ? extends V&gt;)</code></li>
</ul></li>
</ul>

<p>From version <code>0.16</code> onwards, we no longer generate <code>clear*</code> methods on builders, so <code>clearFoo()</code> or <code>clearBar()</code> would not be generated for collection or map attributes.
To clear the contents of collections or maps, use a reset method <code>bar(Collections.emptyList())</code>, or use <a href="#copy-methods">copy methods</a> right after an instance is built.</p>

<p>Since version <code>2.1.11</code> you can use opt-in <a href="style.html#depluralization">depluralization</a> to generate methods named <code>addFoo</code> or <code>putFoo</code> derived from collection attribute named <code>foos</code>.</p>

<p>The set of methods was chosen to represent the minimum required for convenient use. A smaller
selection of methods resulted in noisy conversions all over the code using the generated types. A
bigger selection of methods resulted in a kitchen-sink effect (in effect, duplicating a mutable
collection API!). If you are concerned with the number of methods, consider using tools like
<em>ProGuard</em> to remove unused generated methods in the resulting application.</p>

<p>Why are other kinds of containers not supported in the same way? What about <code>java.lang.Iterable</code>, <code>java.util.Collection</code> or <code>java.util.Queue</code>?
Those other containers are either too-generic or too-specific for the purposes of immutable object modelling.
This might change upon request, of course, and this is what happened with ordered sets and maps (which were recognized with <a href="#natural-reverse">order annotations</a>).
On the plus side, any type is supported as an attribute value. Even though there isn&#39;t any kind of magic support, other container types are still usable:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">DoItYourselfContainer</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">iterable</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="n">ImmutableDoItYourselfContainer</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">iterable</span><span class="o">(</span><span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p><a name="optional"></a></p>

<h3>Optional attributes</h3>

<p>An attribute declared with a return type of <code>com.google.common.base.Optional&lt;T&gt;</code>
defines a logically <a href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained#optional">optional</a>
attribute of type <code>T</code>.</p>

<p>As of version 2.0, <code>java.util.Optional</code>, <code>java.util.OptionalInt</code>, <code>java.util.OptionalLong</code>, <code>java.util.OptionalDouble</code> from Java 8 are also fully supported.</p>

<p>As of version 2.1.1, <code>com.atlassian.fugue.Option</code> and <code>io.atlassian.fugue.Option</code> are also supported.</p>

<p>Optional values can be omitted when building objects, and will default to <code>Optional.absent()</code> (or <code>Optional.empty()</code> in Java 8).
Generated builders have special initializers for optional attributes:</p>

<ul>
<li>For an optional attribute named <code>opt</code>, where elements are of type <code>T</code>

<ul>
<li><code>opt(T)</code> sets present value for T</li>
<li><code>opt(Optional&lt;T&gt;)</code> specifies present or absent</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AllOptional</span> <span class="o">{</span>
  <span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">common</span><span class="o">.</span><span class="na">base</span><span class="o">.</span><span class="na">Optional</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">v1</span><span class="o">();</span>
  <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">v2</span><span class="o">();</span>
  <span class="n">OptionalInt</span> <span class="nf">i1</span><span class="o">();</span>
  <span class="n">OptionalLong</span> <span class="nf">l1</span><span class="o">();</span>
  <span class="n">OptionalDouble</span> <span class="nf">d1</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="c1">// No error as all values are optional</span>
<span class="n">ImmutableAllOptional</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

<span class="n">ImmutableAllOptional</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">v1</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">v2</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="na">i1</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">l1</span><span class="o">(</span><span class="mi">1L</span><span class="o">)</span>
    <span class="o">.</span><span class="na">d1</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p><a name="default-attribute"></a></p>

<h3>Default attributes</h3>

<p>Attributes can have default values provided when none are specified to a <a href="#builder">builder</a>.
To declare a default attribute value, create a non-abstract attribute initializer method
and annotate it with <code>org.immutables.value.Value.Default</code>. If the value is omitted during
construction, this initializer method will be called to retrieve a default value for the attribute.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">PlayerInfo</span> <span class="o">{</span>

  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">long</span> <span class="nf">id</span><span class="o">();</span>

  <span class="nd">@Value.Default</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">name</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">&quot;Anonymous_&quot;</span> <span class="o">+</span> <span class="n">id</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Value.Default</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">gamesPlayed</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">...</span>

<span class="n">PlayerInfo</span> <span class="n">veteran</span> <span class="o">=</span> <span class="n">ImmutablePlayerInfo</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;Fiddler&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">gamesPlayed</span><span class="o">(</span><span class="mi">99</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="n">PlayerInfo</span> <span class="n">anonymous44</span> <span class="o">=</span> <span class="n">ImmutablePlayerInfo</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">44</span><span class="o">);</span>

<span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">anonymous44</span><span class="o">.</span><span class="na">name</span><span class="o">();</span> <span class="c1">// Anonymous_44</span>
</code></pre></div>
<p>Since version <code>2.1</code>, a default attribute initializer method&#39;s body can refer to other default
or derived attributes as long as this does not introduce initialization cycles.
If a cycle is introduced, then an <code>IllegalStateException</code> will be thrown pointing
to attributes which form a cycle.</p>

<p>There&#39;s no need to use <code>@Value.Default</code> to return empty collections as collection attributes are empty by default if not initialized.
Since version <code>2.2</code>. <code>@Value.Default</code> and <code>@Nullable</code> <a href="#collection">collection attributes</a> are supported so you can provide default value if no values have been provided but empty collection or <code>null</code> (if nullable) can be set.</p>

<p>For immutable <a href="#annotations">annotation</a> types, default attributes are defined by using the
<code>default</code> keyword and will have corresponding default constant values initialized if not set.</p>

<p>Default attributes work well with Java 8&#39;s default methods in interfaces, but attributes should be annotated with <code>@Default</code>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">interface</span> <span class="nc">Val</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">anAttribute</span><span class="o">();</span>
  <span class="nd">@Value.Default</span> <span class="k">default</span> <span class="kt">int</span> <span class="nf">otherAttribute</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><a name="derived-attribute"></a></p>

<h3>Derived attributes</h3>

<p>Derived attributes are attributes with values that are read from existing immutable instances, but
cannot be manually set.</p>

<p>To declare a derived attribute, create a non-abstract attribute initializer method and annotate it with
<code>org.immutables.value.Value.Derived</code>. In a similar manner to <a href="#default-attribute">default attributes</a>,
the body of the method should compute and return value of an attribute. Derived attributes act much like
regular methods that simply compute and return a value, but with a single important difference:
values of derived attributes are computed once and stored (at the end of object construction).</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="nf">items</span><span class="o">();</span>

  <span class="nd">@Value.Derived</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">totalCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">i</span> <span class="o">:</span> <span class="n">items</span><span class="o">())</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>

    <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">ImmutableOrder</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">addItems</span><span class="o">(</span><span class="n">Item</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;item1&quot;</span><span class="o">,</span> <span class="mi">11</span><span class="o">))</span>
    <span class="o">.</span><span class="na">addItems</span><span class="o">(</span><span class="n">Item</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;item2&quot;</span><span class="o">,</span> <span class="mi">22</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// total count will be already computed</span>
<span class="kt">int</span> <span class="n">totalCount33</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">totalCount</span><span class="o">();</span>
</code></pre></div>
<p>As with <a href="#default-attribute">default attributes</a>, derived attribute initializer
method bodies can refer to other default or derived attributes as long as there are no cycles.
If a cycle is detected during object construction, then an <code>IllegalStateException</code> will be thrown pointing
to the attribute names which form the cycle.</p>

<p><a name="nullable"></a></p>

<h3>Nullable attributes</h3>

<p>The use of nullable attributes is discouraged. If nullable attributes are really needed, add
a <code>@Nullable</code> annotation to the abstract attribute accessor.  Any annotation with simple name
<code>Nullable</code> will work. Nullable attributes are not required to be set using a builder, and <code>null</code>
values are permitted to initialize them.  Nullable collections and other special types are
not supported. More precisely, adding <code>@Nullable</code> turns an attribute into a &quot;nothing-special&quot;
attribute.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">interface</span> <span class="nc">NullAccepted</span> <span class="o">{</span>
  <span class="nd">@Nullable</span> <span class="n">Integer</span> <span class="nf">i1</span><span class="o">();</span>
  <span class="nd">@Nullable</span> <span class="n">Long</span> <span class="nf">l2</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">NullAccepted</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">ImmutableNullAccepted</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">i1</span><span class="o">(</span><span class="kc">null</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="n">obj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// NullAccepted{i1=null, l2=null}</span>
</code></pre></div>
<h4>Nulls in collection</h4>

<p>As already mentioned, neither collection, nor its elements are supposed to be <code>null</code>. But for the reason of compatibility with the third party libraries or services you may need to allow or to skip (i.e. throw away silently) nulls. Collection attributes could be marked as <a href="#nullable">@Nullable</a>, but what about collection elements? In this case you can mark attribute with special annotations: <code>@AllowNulls</code> or <code>@SkipNulls</code>. These annotations are not supplied by <em>Immutables</em> and any annotations matching by a simple name will take effect — we call this approach BYOA (Bring Your Own Annotations). Please note, that Guava immutable collections do not support nulls, so this feature is only enabled when JDK collections are used, i.e. when Guava not available or <code>@Style(jdkOnly = true)</code>.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Style</span><span class="o">(</span><span class="n">jdkOnly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NullElements</span> <span class="o">{</span>
  <span class="c1">// collection elements</span>
  <span class="nd">@AllowNulls</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">al</span><span class="o">();</span>
  <span class="nd">@SkipNulls</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">sk</span><span class="o">();</span>
  <span class="c1">// map values (but not keys)</span>
  <span class="nd">@AllowNulls</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">bl</span><span class="o">();</span>
  <span class="nd">@SkipNulls</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">sm</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>It is also possible to use <code>@Nullable</code>, <code>@AllowNulls</code>, <code>@SkipNulls</code> as Java 8 type annotation, like <code>List&lt;@Nullable Obj&gt;</code>, but it may not work depending on compiler (works in <em>ECJ</em> and <em>ErrorProne</em>, but not in plain <em>Javac</em>).</p>

<p><a name="lazy-attribute"></a></p>

<h3>Lazy attributes</h3>

<p>A lazy attribute is an initializer method that computes a value lazily and only once.</p>

<p>To declare a lazy attribute, create a non-abstract attribute initializer method and annotate it with
<code>org.immutables.value.Value.Lazy</code>. Similar to <a href="#derived-attribute">derived attributes</a>,
the body of the method should compute and return a value of an attribute.
Lazy attributes act much like regular methods, but compute values the first time they are
accessed and return the same memoized value on subsequent accesses.</p>

<p><strong>Things to be aware of</strong></p>

<ul>
<li>Lazy attributes are not included in <code>equals</code> and <code>hashCode</code> implementations! They are implicitly <a href="#auxiliary">auxiliary</a></li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="nf">items</span><span class="o">();</span>

  <span class="nd">@Value.Lazy</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">totalCost</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">i</span> <span class="o">:</span> <span class="n">items</span><span class="o">())</span>
      <span class="n">cost</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="na">count</span><span class="o">()</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="na">price</span><span class="o">();</span>

    <span class="k">return</span> <span class="n">cost</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">ImmutableOrder</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">addItems</span><span class="o">(</span><span class="n">Item</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;item1&quot;</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
    <span class="o">.</span><span class="na">addItems</span><span class="o">(</span><span class="n">Item</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;item2&quot;</span><span class="o">,</span> <span class="mi">22</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// total cost will be computed now</span>
<span class="kt">int</span> <span class="n">lazilyComputedCost</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">totalCost</span><span class="o">();</span>
<span class="c1">// total cost is already computed and stored value is returned</span>
<span class="n">lazilyComputedCost</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">totalCost</span><span class="o">();</span>
</code></pre></div>
<p>Lazy values are thread-safe and will be computed once and only once, regardless of race conditions.</p>

<p>Unlike <a href="#default-attribute">default</a> or <a href="#derived-attributes">derived</a> attributes,
body of the lazy attribute accessor method could refer to any attribute. If you call lazy attribute during initialization of a <a href="#default-attribute">default</a> or a <a href="#derived-attributes">derived</a> attribute, it will be initialized eagerly, making it an equivalent of a derived attribute.</p>

<p>Current implementation of lazy attributes is very similar to the way they were implemented in older versions of Scala.
Currently, this implementation strategy potentially suffers from the problem described in <a href="http://docs.scala-lang.org/sips/pending/improved-lazy-val-initialization.html">Scala SIP-20</a>.
On the other hand, problems can only occur if you are mixing immutable objects with
mutable/static/thread-local state: cyclic dependencies need to be introduced between different
immutable objects.</p>

<p><a name="check-method"></a></p>

<h3>Precondition check method</h3>

<p>One of the core advantages of immutable objects is the fact that an immutable object is
constructed with proper attribute values in a <em>consistent state</em>, and <em>never changes</em> afterwards.
Sometimes, however, a need arises to check attribute values or a combination of attribute values
for correctness (cross validation).</p>

<p>Normally, these checks would be written in the constructor of a hand-written class. However,
given that there is no hand-written constructor in an immutable implementation class, it is
necessary to specify these checks elsewhere. A non-private method annotated with <code>@Value.Check</code>
can be used to specify preconditions for generated classes:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">NumberContainer</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="nf">nonEmptyNumbers</span><span class="o">();</span>

  <span class="nd">@Value.Check</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkState</span><span class="o">(!</span><span class="n">nonEmptyNumbers</span><span class="o">().</span><span class="na">isEmpty</span><span class="o">(),</span>
        <span class="s">&quot;&#39;nonEmptyNumbers&#39; should have at least one number&quot;</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="c1">// will throw IllegalStateException(&quot;&#39;nonEmptyNumbers&#39; should have at least one number&quot;)</span>
<span class="n">ImmutableNumberContainer</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p>However, one should note how this differs from other kinds of object state validation where
objects may be constructed with values and later validated for correctness regarding business
rules in some context: Precondition checking should not be used to validate against such rules,
but should be used to preserve consistency and guarantee that the instances are usable.</p>

<p>Precondition check methods are executed when immutable objects are <em>instantiated and all attributes are initialized</em>, but <em>before being returned to a caller</em>. Any instance that fails the precondition checks is made unreachable to a caller due to an exception being raised.</p>

<h4>Normalization</h4>

<p>There&#39;s additional variant of using <code>@Value.Check</code> annotation to compute normalized value. If you declare return type of validation method with the return type specified as abstract value type, this validation method will also be able to return substitute &quot;normalized&quot; instance. Normalized instance should always be of the immutable implementations type, otherwise <code>ClassCastException</code> will occur during construction.</p>

<p><em>Be warned that it&#39;s easy to introduce unresolvable recursion, if normalization is implemented without proper checks or with conflicting checks. Always return <code>this</code> if a value do not require normalization.</em></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Normalized</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">value</span><span class="o">();</span>

  <span class="nd">@Value.Check</span>
  <span class="k">default</span> <span class="n">Normalized</span> <span class="nf">normalize</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">()</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">ImmutableNormalized</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
          <span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
          <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">ImmutableNormalized</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
          <span class="o">.</span><span class="na">value</span><span class="o">(-</span><span class="n">value</span><span class="o">())</span>
          <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="n">shouldBePositive2</span> <span class="o">=</span> <span class="n">ImmutableNormalized</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">value</span><span class="o">(-</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
    <span class="o">.</span><span class="na">value</span><span class="o">();</span>
</code></pre></div>
<p><a name="copy-methods"></a></p>

<h3>Copy methods</h3>

<p><code>with*</code> methods (withers) allow to modify values of attributes by returning a new
immutable object with new value applied and the rest of attributes unchanged.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="na">withValue</span><span class="o">(</span><span class="n">counter</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>A cheap reference equality <code>==</code> check is added to prevent a copy of the same value by returning <code>this</code>.
Primitives are compared using the <code>==</code> value check. Primitive <code>float</code> and <code>double</code> are compared strictly by using <code>Float.floatToIntBits</code> and <code>Double.doubleToLongBits</code> respectively, consistently with how <code>Float.equals</code> and <code>Double.equals</code> work.
For strings and primitive wrapper types we use <code>Object.equals</code> equality. But in general, full equality checks were omitted: in practice it may be less computationally expensive to create new copy of a value than to check some attribute for deep-equality.</p>

<p>Wither methods are implemented to copy with structural sharing. It is useful to change one attribute value, but have other attributes values reference the same values as before, including any immutable collections and nested values that are wasteful to rebuild. New values will effectively
share the subgraphs of old values, which is desirable in many cases.</p>

<p>While it was tempting to generated a bunch of methods to support collections and maps such as
<code>withItemAdded</code> or <code>withKeyValuePut</code>, they might require a lot of variation like <em>add last</em> or
<em>add first</em> and will hide the fact that immutable collections are being rebuilt and/or rehashed, which is not always desirable for immutable collections. As of now, there&#39;s only simple value replacement for all kinds of attributes. New collection values are guaranteed to be copied as immutable unless already immutable.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">Value</span> <span class="n">changedValue</span> <span class="o">=</span>
    <span class="n">ImmutableValue</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">existingValue</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withName</span><span class="o">(</span><span class="s">&quot;Changed Name&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withValues</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&quot;Only new value&quot;</span><span class="o">))</span> <span class="c1">// replacing any copied collection</span>
</code></pre></div>
<p>Copy methods are generated by default, and to use them you need obtain a reference to an
immutable implementation class instance, rather than an up-casted abstract value type reference.</p>

<p>Setting the <code>@Value.Immutable(copy = false)</code> annotation parameter will <em>disable</em> the generation
of copy methods.</p>

<p><a name="singleton"></a></p>

<h3>Singleton instances</h3>

<p>It is easy to create &quot;empty&quot; or &quot;default&quot; instances that will be singletons.
Use the <code>@Value.Immutable(singleton = true)</code> annotation parameter to generate singleton instances.
Use the concise <code>of()</code> factory method to obtain a singleton instance.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span><span class="o">(</span><span class="n">singleton</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Data</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">chunks</span><span class="o">();</span>
<span class="o">}</span>

<span class="o">...</span>
<span class="kt">boolean</span> <span class="n">willBeTrue</span> <span class="o">=</span>
    <span class="n">ImmuableData</span><span class="o">.</span><span class="na">of</span><span class="o">()</span> <span class="o">==</span> <span class="n">ImmuableData</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
<span class="c1">// true</span>

<span class="kt">boolean</span> <span class="n">willBeTrueAlso</span> <span class="o">=</span>
    <span class="n">ImmuableData</span><span class="o">.</span><span class="na">of</span><span class="o">().</span><span class="na">chunks</span><span class="o">().</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="c1">// true</span>
</code></pre></div>
<p>The abstract value type of a singleton should not have any mandatory attributes, otherwise the
generation of singletons will not be possible.
You can make attributes non-mandatory by using <a href="#default-attribute">default</a> or <a href="#optional">optional</a> attributes.</p>

<p>As it stands, empty singleton instances can be combined with builders and constructors as long
as all attributes are non-mandatory. If you only want to provide a singleton instance, disable
builders and constructors:</p>

<ul>
<li>Use <code>singleton = true</code> and <code>builder = false</code> with <code>@Value.Immutable</code> annotations</li>
<li>Avoid the use of <code>@Value.Parameter</code>, to avoid generating constructors</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span><span class="o">(</span><span class="n">singleton</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">builder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="c1">// Limit constructor accessibility to a package if needed.</span>
  <span class="c1">// Private access will not work as ImmutableSingleton should</span>
  <span class="c1">// be able to extend Singleton</span>
  <span class="n">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="o">...</span>
<span class="n">Singleton</span> <span class="n">singleInstance</span> <span class="o">=</span> <span class="n">ImmutableSingleton</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
</code></pre></div>
<p><strong>Things to be aware of</strong></p>

<ul>
<li>If an abstract value type contains mandatory attributes but the generation of a singleton is requested:

<ul>
<li>Compilation error: could not generate default value for mandatory field.</li>
</ul></li>
</ul>

<p><a name="interning"></a></p>

<h3>Instance interning</h3>

<p>There are cases where a number of values of a given type are expected to be finite and
measurable performance improvements may be gained by interning those instances.</p>

<p>If all you need is to <em>strongly</em> intern all instances of particular value type — <em>Immutables</em> can do that for you.
Use the <code>@Value.Immutable(intern = true)</code> annotation parameter to enable strong interning:</p>

<ul>
<li>Any object returned by a builder or constructor will be interned and a &quot;canonical&quot; instance returned</li>
<li><code>equals</code> will be short-circuited to object reference equality.</li>
</ul>

<p><em>Strong</em> interning is supported by default and since version <code>2.6.0</code> <em>weak</em> interning is also supported via <code>@Value.Style(weakInterning = true)</code>.</p>

<p>Any other forms of interning including partial range interning
were left out to be implemented externally. There is, however, a module <code>org.immutables:ordinal</code>
which supports sophisticated domain-based interning of enum-like objects. See the documentation of
classes in that module.</p>

<p><a name="prehashed"></a></p>

<h3>Precomputed hashCode</h3>

<p>If an immutable class has a lot of attributes, or attributes may contain reasonably large
object graphs, then it may become inefficient to recompute <code>hashCode</code> value again and again
(when inserting instances into a <code>HashMap</code>, for example).</p>

<p>For such cases, hash codes can be precomputed on construction and stored for fast retrieval.
Just use the <code>@Value.Immutable(prehash = true)</code> annotation parameter to precompute hash values in advance.</p>

<p><a name="redacted"></a></p>

<h3>Redacted attributes</h3>

<p>Since v2.5.0 <code>Value.Redacted</code> annotation was introduced to hide or mask attribute values
from auto-generated <code>toString</code> method. This can be useful to make sure PII will not
leak to logs or something like that. It will be just excluded by default.
However, you can choose to put special masking characters next to the attribute
instead of characters, like 3 asterisks or 4 pound signs: a replacement string
can be set using <code>redactedMask</code> style attribute.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Style</span><span class="o">(</span><span class="n">redactedMask</span> <span class="o">=</span> <span class="s">&quot;####&quot;</span><span class="o">)</span>
<span class="o">..</span>
<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RedactedMask</span> <span class="o">{</span>
  <span class="nd">@Value.Redacted</span>
  <span class="n">String</span> <span class="nf">ssn</span><span class="o">();</span>
  <span class="nd">@Value.Redacted</span>
  <span class="n">String</span> <span class="nf">secret</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">// toString output: RedactedMask{ssn=####, secret=####}</span>
<span class="c1">// without setting style it would be just: RedactedMask{}</span>
</code></pre></div>
<p>See <a href="#opaque-containers">opaque containers</a> as the more disciplined, customizable and type-safe way to achieve the same. Or see yet another alternative in the form of auxiliary attributes just <a href="#auxiliary">below</a>.</p>

<p><a name="auxiliary"></a></p>

<h3>Auxiliary attributes</h3>

<p>Sometimes it is desirable to exclude an attribute from the generated <code>equals</code>, <code>hashCode</code>, and <code>toString</code> methods.</p>

<p>Attributes annotated with <code>@Value.Auxiliary</code> will be stored and will be accessible, but are
excluded from <code>equals</code>, <code>hashCode</code> and <code>toString</code> method implementations. <a href="#lazy-attribute">Lazy</a>
attributes are always acting as <em>auxiliary</em>.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span><span class="o">(</span><span class="n">intern</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">interface</span> <span class="nc">TypeDescriptor</span> <span class="o">{</span>
  <span class="c1">// Instances are interned only by qualified name</span>
  <span class="n">String</span> <span class="nf">qualifiedName</span><span class="o">();</span>
  <span class="nd">@Value.Auxiliary</span>
  <span class="n">TypeElement</span> <span class="nf">element</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>If this is not enough, <code>hashCode</code>, <code>equals</code>, and <code>toString</code> methods can be <a href="#custom-equals-hashcode-tostring">customized directly</a>.</p>

<p><a name="custom-equals-hashcode-tostring"></a></p>

<h3>Customize toString, hashCode and equals</h3>

<p>It&#39;s quite easy to customize the generated <code>toString</code>, <code>hashCode</code> and <code>equals</code> methods.
The <em>Immutables</em> processor will simply use provided non-abstract definitions for those
methods if any are present in an abstract value type:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">OmniValue</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">object</span> <span class="k">instanceof</span> <span class="n">OmniValue</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">&quot;OmniValue{*}&quot;</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">boolean</span> <span class="n">willBeTrue</span> <span class="o">=</span>
    <span class="n">ImmutableOmniValue</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">build</span><span class="o">()</span>
        <span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">new</span> <span class="n">OmniValue</span><span class="o">()</span> <span class="o">{});</span>
</code></pre></div>
<p>Additionally, manually written <code>equals</code> and <code>hashCode</code> methods will automatically work
correctly with <a href="#interning">instance interning</a> and <a href="#prehashed">precomputed hashCode</a> features!</p>

<p><em>Obviously, you should only provide manual implementations of the <code>equals</code> and <code>hashCode</code>
methods if you really know what you are doing!</em></p>

<p>If you just want exclude some attributes from the generated <code>equals</code> and <code>hashCode</code> methods,
a simpler alternative is to mark them as <a href="#auxiliary">auxiliary</a> instead of writing your
own custom implementations.</p>

<p><a name="annotations"></a></p>

<h3>Immutable Annotation</h3>

<p>Annotations types can also be annotated as <code>@Value.Immutable</code>. Immutable annotation
implementations will be generated which behave according to the specification. You can
expect array, <a href="#default-attribute">default attributes</a>, and all other features to work
in the same way as for regular immutable objects.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">MyAnnotation</span> <span class="o">{</span>
  <span class="n">String</span><span class="o">[]</span> <span class="nf">value</span><span class="o">();</span>
  <span class="kt">boolean</span> <span class="nf">enable</span><span class="o">()</span> <span class="k">default</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="n">ImmutableMyAnnotation</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">addValue</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">enable</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p>If annotations reside in a different library or package, you still can generate implementations
and builders using the <a href="#include">Include</a> annotation.</p>

<p><a name="serialization"></a></p>

<h3>Serialization</h3>

<p>Basic Java binary serialization is supported in the following way:</p>

<ul>
<li>Detect if an abstract value type implements <code>java.lang.Serializable</code></li>
<li>Make lazy attributes <code>transient</code></li>
<li>Copy the <code>serialVersionUID</code> value from the abstract value type to the immutable implementation type</li>
<li>Generate a <code>readResolve</code> method implementation to preserve <a href="#singleton">singleton</a> and <a href="#interning">interned</a> instances.</li>
</ul>

<p>Advanced Java binary serialization annotations are available in the <code>serial</code> module
(since v2.0.12):</p>

<ul>
<li><p><a href="https://search.maven.org/artifact/org.immutables/serial/2.7.1/jar">org.immutables:serial:2.7.1</a></p></li>
<li><p><code>@Serial.Version</code> — to apply a serial version to enclosing value types</p></li>
<li><p><code>@Serial.Structural</code> — enables special structural serialization. Using structural serialization enables you to evolve your data in a flexible manner. Having new optional fields added, scalars changed to arrays or collection kind changed from <code>Set</code> to <code>List</code> will not break compatibility of serialized value objects.</p></li>
<li><p>immutable value type generated from types annotated with either <code>@Serial.Version</code> or <code>@Serial.Structural</code> will auto-implement <code>java.lang.Serializable</code> if not already.</p></li>
</ul>

<p>For JSON serialization options see the <a href="/json.html">JSON</a> guide.</p>

<p><a name="modifiable"></a></p>

<h3>Modifiable classes</h3>

<p>While <em>Immutables</em> is heavily biased towards immutability, limited support for mutable implementations
is also provided.</p>

<p>Use the annotation <code>@Value.Modifiable</code> with or without a corresponding <code>@Value.Immutable</code>.
The generated mutable companion class will have the prefix <code>Modifiable</code>.
It is more limited and arguably more difficult to get right semantically, but it may be useful
as a buffer, <em>uber-builder</em>, or partially-initialized implementation. We believe that modifiable
companion class is a better alternative to:</p>

<ul>
<li>Polluting builders with attribute query and <em>isSet</em>/<em>isInitialized</em> methods.</li>
<li>Introducing dangerous <code>buildPartial()</code> methods that produce incomplete immutable instances.</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="nd">@Value.Modifiable</span>
<span class="kd">interface</span> <span class="nc">Item</span> <span class="o">{</span>
  <span class="n">String</span> <span class="nf">getName</span><span class="o">();</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">getCount</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>

<span class="c1">// When simple workflow of regular Builder is not enough</span>

<span class="n">ModifiableItem</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ModifiableItem</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
    <span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Super Item&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addCount</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">addCount</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="n">item</span><span class="o">.</span><span class="na">getCount</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">isIntialized</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">ImmutableItem</span> <span class="n">immutableItem</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">toImmutable</span><span class="o">();</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">immutableItem</span><span class="o">);</span>
  <span class="c1">// Item{name=Super Item, count=[1, 2, 3]}</span>
<span class="o">}</span>

<span class="n">item</span><span class="o">.</span><span class="na">clear</span><span class="o">()</span>
    <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">ImmutableItem</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;First&quot;</span><span class="o">).</span><span class="na">addCount</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">build</span><span class="o">())</span>
    <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">ImmutableItem</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;Second&quot;</span><span class="o">).</span><span class="na">addCount</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
<span class="c1">// ModifiableItem{name=Second, count=[4, 5, 6]}</span>
</code></pre></div>
<p>The naming conventions of modifiable classes can be changed using <a href="/style.html">styles</a>,
even going as far as creating <a href="/factory.html">builders in disguise</a>.</p>

<p><a name="generics"></a></p>

<h3>Generics are fully supported!</h3>

<p>Starting with version 2.2 generic parameters are supported and can have upper bounds specified if needed.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">interface</span> <span class="nc">TreeElement</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">interface</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Serializable</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">TreeElement</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeElement</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">elements</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">interface</span> <span class="nc">Leaf</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Serializable</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">TreeElement</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span> <span class="n">T</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">TreeElement</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">tree</span> <span class="o">=</span>
    <span class="n">ImmutableNode</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">addElements</span><span class="o">(</span><span class="n">ImmutableLeaf</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;A&quot;</span><span class="o">))</span>
        <span class="o">.</span><span class="na">addElements</span><span class="o">(</span><span class="n">ImmutableLeaf</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;B&quot;</span><span class="o">))</span>
        <span class="o">.</span><span class="na">addElements</span><span class="o">(</span>
            <span class="n">ImmutableNode</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">addElements</span><span class="o">(</span><span class="n">ImmutableLeaf</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;C&quot;</span><span class="o">))</span>
                <span class="o">.</span><span class="na">addElements</span><span class="o">(</span><span class="n">ImmutableLeaf</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;D&quot;</span><span class="o">))</span>
                <span class="o">.</span><span class="na">build</span><span class="o">())</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>
<p>See <a href="#wrapper-types">Wrapper types</a> for other examples illustrating the use of generics.</p>

<h3>Annotation injection</h3>

<p>Experimental annotation injection introduced in version <code>2.6.0</code>: allows injecting annotation on fields, accessors, initializer, immutable and builder types etc. Injection directives are defined as custom annotations meta-annotated with <code>@InjectAnnotation</code> in new <code>org.immutables:annotate</code> module. Allow some non-trivial annotation code construction, see Javadoc of <code>@InjectAnnotation</code> for details.</p>

<p>The motivation of annotation injection is integration with some introspection-based toolkits and frameworks.</p>

<p><a name="warnings"></a></p>

<h3>Warnings</h3>

<p>The <em>Immutables</em> annotation processor have dozens of checks and issues errors and warning where it&#39;s impossible to generate certain elements or certain features are error prone and discouraged. When you use <code>@Nullable</code> on a primitive or when one <code>Value.Immutable</code> type extends another <code>Value.Immutable</code>, you&#39;ll get an error. For missing, superfluous or ignored annotations or discouraged combinations, you will get warnings. You can suppress such warnings using <code>SuppressWarnings(&quot;immutables&quot;)</code> or <code>SuppressWarnings(&quot;all&quot;)</code> on an element or its enclosing elements.</p>

<p>See also <a href="https://github.com/immutables/immutables/blob/master/value/src/org/immutables/value/Value.java">Style.generateSuppressAllWarnings</a> style attribute to adjust warnings in the generated code.</p>

<hr>

<h2>Patterns</h2>

<p>This section contains common patterns and recipes using <em>Immutables</em>
that are useful but are not actually features by themselves.</p>

<p><a name="wrapper-types"></a></p>

<h3>Wrapper types</h3>

<p>Very often we&#39;re creating wrapper types around primitives, strings, and commonly used types
to radically improve type safety. We definitely don&#39;t want to have unsafe &quot;stringly typed&quot;
code all over the place.</p>

<p>However, types should also introduce the absolute minimum of syntactic overhead: If such
wrapper types are easy to create and use, then fewer accidental errors will end up in code.</p>

<p>Use a supertype and corresponding styles to describe your wrapper types:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="c1">// declare style as meta annotation as shown</span>
<span class="c1">// or on package/top-level class</span>
<span class="c1">// This is just an example, adapt to your taste however you like</span>
<span class="nd">@Value.Style</span><span class="o">(</span>
    <span class="c1">// Detect names starting with underscore</span>
        <span class="n">typeAbstract</span> <span class="o">=</span> <span class="s">&quot;_*&quot;</span><span class="o">,</span>
    <span class="c1">// Generate without any suffix, just raw detected name</span>
        <span class="n">typeImmutable</span> <span class="o">=</span> <span class="s">&quot;*&quot;</span><span class="o">,</span>
    <span class="c1">// Make generated public, leave underscored as package private</span>
        <span class="n">visibility</span> <span class="o">=</span> <span class="n">ImplementationVisibility</span><span class="o">.</span><span class="na">PUBLIC</span><span class="o">,</span>
    <span class="c1">// Seems unnecessary to have builder or superfluous copy method</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="nd">@Value.Immutable</span><span class="o">(</span><span class="n">builder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="kc">false</span><span class="o">))</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Wrapped</span> <span class="o">{}</span>

<span class="c1">// base wrapper type</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">value</span><span class="o">();</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="o">...</span>
<span class="c1">// Declare wrapper types/domain values</span>

<span class="nd">@Value.Immutable</span> <span class="nd">@Wrapped</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">_LongId</span> <span class="kd">extends</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="nd">@Value.Immutable</span> <span class="nd">@Wrapped</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">_PersonName</span> <span class="kd">extends</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="nd">@Value.Immutable</span> <span class="nd">@Wrapped</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">_VehicleMake</span> <span class="kd">extends</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="o">...</span>
<span class="c1">// Enjoy your wrapper value types</span>

<span class="n">LongId</span> <span class="n">id</span> <span class="o">=</span> <span class="n">LongId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">123L</span><span class="o">);</span>

<span class="n">PersonName</span> <span class="n">name</span> <span class="o">=</span> <span class="n">PersonName</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;Vasilij Pupkin&quot;</span><span class="o">);</span>

<span class="n">VehicleMake</span> <span class="n">make</span> <span class="o">=</span> <span class="n">VehicleMake</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;Honda&quot;</span><span class="o">);</span>
</code></pre></div>
<p>You can make it so that only <code>@Wrapped</code> is needed without corresponding <code>@Value.Immutable</code> annotation, if you follow the recipe for <a href="http://immutables.github.io/style.html#custom-immutable-annotation">custom immutable annotations</a>.</p>

<p><a name="tuples"></a></p>

<h3>Tuple style</h3>

<p>Using styles you can create types with only constructor generated which includes all attributes as parameters.
The key style here is <code>allParameters</code> which automatically makes constructor for all parameters regardless if they are annotated with <code>@Value.Parameter</code>.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Style</span><span class="o">(</span>
    <span class="c1">// Generate construction method using all attributes as parameters</span>
    <span class="n">allParameters</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span>
    <span class="c1">// Changing generated name just for fun</span>
    <span class="n">typeImmutable</span> <span class="o">=</span> <span class="s">&quot;*Tuple&quot;</span><span class="o">,</span>
    <span class="c1">// We may also disable builder</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="nd">@Value.Immutable</span><span class="o">(</span><span class="n">builder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">))</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Tuple</span> <span class="o">{}</span>
<span class="o">...</span>
<span class="c1">// declare type with &quot;tuple&quot; style</span>
<span class="nd">@Value.Immutable</span> <span class="nd">@Tuple</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Complex</span> <span class="o">{</span>
  <span class="kt">double</span> <span class="nf">re</span><span class="o">();</span>
  <span class="kt">double</span> <span class="nf">im</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>

<span class="n">Complex</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ComplexTuple</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mf">1d</span><span class="o">,</span> <span class="mf">0d</span><span class="o">);</span>
</code></pre></div>
<p>You can make it so that only <code>@Tuple</code> is needed without corresponding <code>@Value.Immutable</code> annotation, if you follow the recipe for <a href="http://immutables.github.io/style.html#custom-immutable-annotation">custom immutable annotations</a>.</p>

<p><a name="deepImmutablesDetection"></a></p>

<h3>Wrapper/Tupple initializers inlined as alternative setters with Deep Immutables Detection</h3>

<p>When both the Wrapper (i.e. single) and the Tupple (i.e. multiple) value objects are used in another @Immutable, it can be useful to have short-cuts to avoid having to explicitly build the trivial contained inner value object when constructing the outer object.  This is possible with the <code>deepImmutablesDetection</code> style:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="nd">@Value.Style</span><span class="o">(</span><span class="n">deepImmutablesDetection</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">depluralize</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Line</span> <span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="nf">points</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Value.Immutable</span>
<span class="nd">@Value.Style</span><span class="o">(</span><span class="n">allParameters</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">x</span><span class="o">();</span>
  <span class="kt">int</span> <span class="nf">y</span><span class="o">();</span>
<span class="o">}</span>

<span class="n">ImmutableLine</span> <span class="n">line</span> <span class="o">=</span> <span class="n">ImmutableLine</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">addPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// implicit addPoint(ImmutablePoint.of(1, 2))</span>
  <span class="o">.</span><span class="na">addPoint</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
  <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<h3>Expressive factory methods</h3>

<p>There were feature requests to customize the names of constructor methods and, in addition, provide construction hooks.
We identified two interconnected needs:</p>

<ul>
<li>Construct an object with some values that are different than factory method parameters, but derived from those parameters</li>
<li>Give a descriptive name to a factory method to highlight how parameters will be used to construct an object</li>
</ul>

<p>Having considered special annotation parameters and hook-methods, we eventually came up
with... Nothing. This, surprisingly, solves the problem and requires no features: Simply declare
factory methods on abstract value classes and forward calls to constructor methods of immutable
implementation classes.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">x</span><span class="o">();</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">y</span><span class="o">();</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Point</span> <span class="nf">origin</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutablePoint</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Point</span> <span class="nf">of</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutablePoint</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Point</span> <span class="nf">fromPolar</span><span class="o">(</span><span class="kt">double</span> <span class="n">r</span><span class="o">,</span> <span class="kt">double</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutablePoint</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">Math</span><span class="o">.</span><span class="na">cos</span><span class="o">(</span><span class="n">t</span><span class="o">),</span> <span class="n">r</span> <span class="o">*</span> <span class="n">Math</span><span class="o">.</span><span class="na">sin</span><span class="o">(</span><span class="n">t</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>You may also want to use forwarding factory methods to hide the implementation class from the surface of
an abstract value type API. In example above, notice how the use of <code>ImmutablePoint</code> does not leak
through <code>Point</code>&#39;s public interface.</p>

<p><a name="hide-implementation"></a></p>

<h3>Hide implementation class</h3>

<p>In addition to the examples above, it&#39;s also possible to hide builder implementations in
the same manner using nested abstract <a href="#builder">Builders</a>. While it increases verbosity,
it means that implementation classes are not exposed as a public API:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="c1">// Make generated class package private</span>
<span class="nd">@Value.Style</span><span class="o">(</span><span class="n">visibility</span> <span class="o">=</span> <span class="n">ImplementationVisibility</span><span class="o">.</span><span class="na">PACKAGE</span><span class="o">)</span>
<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span> <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">x</span><span class="o">();</span>
  <span class="nd">@Value.Parameter</span> <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">y</span><span class="o">();</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Point</span> <span class="nf">of</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutablePoint</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Builder</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutablePoint</span><span class="o">.</span><span class="na">builder</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="c1">// Signatures of abstract methods should match to be</span>
  <span class="c1">// overridden by implementation builder</span>
  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Builder</span> <span class="o">{</span>
    <span class="n">Builder</span> <span class="nf">x</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">);</span>
    <span class="n">Builder</span> <span class="nf">y</span><span class="o">(</span><span class="kt">double</span> <span class="n">y</span><span class="o">);</span>
    <span class="n">Point</span> <span class="nf">build</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><a name="smart-data"></a></p>

<h3>Smart data</h3>

<p>Immutable objects act very well in the role of &quot;smart data&quot;: In addition to being a pure data
container, a value object can also carry domain-specific knowledge and the capability to perform
computations. While services and entities orchestrate the execution of business logic, value
objects handle computations that are specific to problem domain, but agnostic to any particular
business context.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">OriginDestination</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Airport</span> <span class="nf">origin</span><span class="o">();</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Airport</span> <span class="nf">destination</span><span class="o">();</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDomestic</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">origin</span><span class="o">().</span><span class="na">country</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">destination</span><span class="o">().</span><span class="na">country</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isCrossCityTransit</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">origin</span><span class="o">().</span><span class="na">city</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">destination</span><span class="o">().</span><span class="na">city</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">OriginDestination</span> <span class="nf">reverse</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutableOriginDestination</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">destination</span><span class="o">(),</span> <span class="n">origin</span><span class="o">());</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>
<p>Go ahead! Enrich value objects with methods that compute values — push computation complexity to the right place!</p>

<h3>Non-public attributes</h3>

<p>Particular attributes may become redundant from the standpoint of the public interface of an
abstract value class. Lowering the visibility may help to hide attribute from API consumers,
however it will still be exposed as <code>public</code> on builders and as constructor parameters:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">abstract</span> <span class="n">String</span> <span class="nf">value</span><span class="o">();</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Name</span> <span class="nf">of</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ImmutableName</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">...</span>

<span class="n">Name</span> <span class="n">name</span> <span class="o">=</span> <span class="n">Name</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;The Rose&quot;</span><span class="o">);</span>
<span class="n">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="c1">// &quot;The Rose&quot;</span>
</code></pre></div>
<h3>Null-Object pattern in attribute values</h3>

<p>As an alternative to using <code>Optional&lt;T&gt;</code> attributes, the <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null-object pattern</a> could be used.
This requires no special support from <em>Immutables</em>; just use <a href="#default-attribute">default attributes</a>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Stars</span> <span class="o">{</span>
  <span class="n">NONE</span><span class="o">,</span> <span class="n">ONE</span><span class="o">,</span> <span class="n">TWO</span><span class="o">,</span> <span class="n">THREE</span><span class="o">,</span> <span class="n">FOUR</span><span class="o">,</span> <span class="n">FIVE</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Value.Immutable</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Hotel</span> <span class="o">{</span>
  <span class="nd">@Value.Default</span>
  <span class="kd">public</span> <span class="n">Stars</span> <span class="nf">stars</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Stars</span><span class="o">.</span><span class="na">NONE</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h3>Opaque containers</h3>

<p>It may sometimes be necessary to prevent fields from being exposed via the <code>toString</code> method, or to
handle <code>hashCode</code> or <code>equals</code> in a very specific manner. It&#39;s always better to avoid introducing
ad-hoc features into the annotation processor to achieve this! For example, if you want to mask
some confidential data from a <code>toString</code> method, create an opaque wrapper for this data:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span><span class="o">(</span><span class="n">builder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Confidential</span> <span class="o">{</span>
  <span class="nd">@Value.Parameter</span>
  <span class="kd">abstract</span> <span class="n">String</span> <span class="nf">value</span><span class="o">();</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">&quot;&lt;NON DISCLOSED&gt;&quot;</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Then, it can be used safely as an attribute:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="nd">@Value.Immutable</span>
<span class="kd">interface</span> <span class="nc">Val</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">number</span><span class="o">();</span>
  <span class="n">Confidential</span> <span class="nf">confidential</span><span class="o">();</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="c1">// toString</span>
<span class="s">&quot;Val{number=1, confidential=&lt;NON DISCLOSED&gt;}&quot;</span>
</code></pre></div>
<p>See also <a href="#redacted">redacted attributes</a> for hiding or masking attribute values in generated <code>toString</code>.
See also <a href="#auxiliary">auxiliary attributes</a> for excluding attribute from <code>hashCode</code>, <code>equals</code>, <code>toString</code></p>

</section>
<footer class="jumbotron">
  <div class="container">
    <h2>Guides</h2>

<ul>
<li><a href="/getstarted.html">Get started!</a></li>
<li><a href="/intro.html">Inception</a></li>
<li><a href="/immutable.html">Immutable objects</a></li>
<li><a href="/factory.html">Factory builders</a></li>
<li><a href="/functional.html">Functions and Predicates (for Java 7)</a></li>
<li><a href="/style.html">Style customization</a></li>
<li><a href="/json.html">JSON serialization</a></li>
<li><a href="/mongo.html">MongoDB repositories</a></li>
<li><a href="/encoding.html">Encoding: Customizing attributes and builders (experimental)</a></li>
<li><a href="/apt.html">Using annotation processor in IDE</a></li>
</ul>

<h2>Get involved</h2>

<ul>
<li>Clone source repository, contribute bug reports and fixes on <a href="https://github.com/immutables/immutables">GitHub immutables/immutables</a></li>
<li>News and announcements on twitter <a href="https://twitter.com/ImmutablesOrg">@ImmutablesOrg</a></li>
<li>Ask questions or give feedback and ideas using mailing group <a href="https://groups.google.com/forum/#!forum/immutables">immutables at googlegroups.com</a></li>
</ul>

<p><a href="/license.html">Apache License 2.0</a></p>

    <!--<div><h2>Posts</h2>
      <ul>
        
      </ul>
    </div>-->
  </div>
</footer>
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script defer src="/gfx/jquery.toc.min.js"></script>
<script>
$(function() {
  $('#toc').toc({
    container: '.documentation',
    selectors: 'h1,h2,h3,h4',
    anchorName: function(i, heading, prefix) {
      heading = $(heading).text();
      if (heading.trim) heading = heading.trim();
      return heading.toLowerCase().replace(/ /g, '-').replace(/[^a-z^\-]+/g, '');
    },
  })
})
</script>
</body>
</html>
