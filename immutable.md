---
title: 'Immutable objects'
layout: page
---

Overview
--------
[Get started!](/getstarted.html) create an _abstract value type and then add annotation to generate _immutable implementation class_!

See [sample generated code](/generated.html) for an example of what kind of code is being generated by the processor.

Read boring [Introduction](/intro.html).

Or jump straight to the [features](#features) implemented!

--------
Concepts
--------

<a name="abstract-value"></a>
### Abstract value type
Abstract value type — manually written non-final (usually abstract) class or interface (or even annotation type) that defines value type and is annotated with `org.immutable.value.Value.Immutable` annotation. May contain [attributes](#attributes) and other meta-data, as well as regular java methods (and fields if needed). It is strongly recommended to not introduce visible mutable state in abstract value class. Abstract value types are used as the source model for generated code. [Get started!](/getstarted.html).

<a name="attributes"></a>
### Attributes
An attribute hold value which cannot be changed after object is created.
It is intentionally named "attribute" to distinguish it from "field" and JavaBean "property" and also to draw similarity with annotation attributes. It is defined by accessor method: zero argument, non-`void` java method.
No annotation required on abstract accessor method to became attribute, however some attributes,
such as attributes with [default values](#default-attribute)
are non-`abstract` methods that have body that computes value,
thus such accessors require special annotation to distinguish from regular method.

### Immutable implementation class
[Generated](/generated.html) `final class` that extends manually-written [abstract value type](#abstract-value)
and implements all declared accessor methods as well as supporting fields, methods, constructors and builder class.
Immutable implementation class implements abstract attribute accessors
for scalar primitive and object reference types, special support provided for [collection attributes](#collection)
and some other types.
`Object`'s methods `equals`, `hashCode` and `toString` are overridden and fully dependent on attribute values
rather that object identity.
Immutable implementation class is primary, but not the only source code artifact
generated by _Immutables_ annotation processor.

<a name="features"></a>
--------
Features
--------

<a name="builder"></a>
### Builder
By default, builders are generated for each immutable implementation class.
Builders enable expressive construction of object using named attribute initializers,
and generally builders compensates lack of named and optional constructor arguments in Java language.

+ To create builder invoke static `builder()` method on generated immutable implementation class
+ Invoke attribute initializer methods to set attributes
+ Call `build()` methods to construct immutable instance after attributes are initialized.
  Build method will fail if any mandatory attribute is omitted.

```java
// builder methods illustrated
ImmutableObject.builder()
    .foo(1442)
    .bar(true)
    .addBuz("a")
    .addBuz("1", "2")
    .addAllBuz(iterable)
    .putQux(key, value)
    .build();
```

If builder became redundant in presence of [constructor](#constructor), you can disable generation of builder
using `@Value.Immutable(builder = false)` annotation parameter.

In advanced usage of builders you will want to pass builders that builds different types of objects but conform to the
same interface, akin to original [Builder pattern](http://en.wikipedia.org/wiki/Builder_pattern).
It is archivable by declaring static nested class named "Builder",
which will be extended by generated builder.

```java
interface Weapon {
  // we are peaceful: our weapon won't get any fire methods )
}

interface WeaponBuilder {
  // Generated builders will implement this method
  // It is compatible with signature of generated builder methods where
  // return type is narrowed to Railgun or RocketLauncher
  Weapon build();
}

@Value.Immutable
public abstract class Railgun implements Weapon {
  public abstract static class Builder implements WeaponBuilder {}
}

@Value.Immutable
public abstract class RocketLauncher implements Weapon {
  public abstract static class Builder implements WeaponBuilder {}
}

class Builders {
  void buildAndThrowAwayWeapon(WeaponBuilder builder) {
    Weapon throwawayWeapon = builder.build();
  }
  
  void exercise() {
    buildAndThrowAwayWeapon(ImmutableRailgun.builder());
    buildAndThrowAwayWeapon(ImmutableRocketLauncher.builder());
  }
}
```

Explicitly declared abstract "Builder" could specify all needed `extends` or `implements` declarations as well as it could have convenience methods that will show up on immutable object builder. However, special care should be taken in order to maintain structural compatibility of
declared builder supertype and generated builders, otherwise compile error will occur in generated code.

Using "forwarding" factory methods and abstract builder it is possible to hide generated implementation type and it's builder from the API. See [example](#hide-implementation).

<a name="constructor"></a>
### Constructor method
As an alternative to builder, it is possible to provide concise "constructor" factory method.
Constructor will be available as `static` method named `of` on immutable implementation class.

In order to generate constructor method, certain attributes should be annotated
with `org.immutables.value.Value.Parameter` annotation.

```java
@Value.Immutable
public abstract class HostWithPort {
  @Value.Parameter
  public abstract String hostname();
  @Value.Parameter
  public abstract int port();
}
...
HostWithPort hostWithPort = ImmutableHostWithPort.of("localhost", 8081);

boolean willBeTrue = hostWithPort.equals(
    ImmutableHostWithPort.builder()
        .hostname("localhost")
        .port(8081)
        .build());
```

If there's more that one constructor parameter it is advised to put `order` annotation attribute to make constructor parameter order deterministic across java compilers that may not honor source order. Source ordering currently works for Javac and Eclipse JDT compilers.

**Possible problems**

+ If not all mandatory attributes are marked as `@Value.Parameter`
  - Compilation error: could not generate default value for mandatory field.

<a name="collection"></a>
### Array, Collection and Map attributes

Following collection types enjoy built-in support for convenient usage:

+ `T[]`

+ `java.util.List<T>`

+ `java.util.Set<T>`

+ `java.util.Map<K, V>`

Array attributes are being cloned for safety.
Collection attributes are backed by Guava immutable collections,
moreover, `java.util.Set` and `java.util.Map` with `enum` keys
are backed by efficient `EnumSet` and `EnumMap` implementations.

In addition, ordered maps and sets are supported for natural and reverse natural ordering
using `@Value.NaturalOrder` and `@Value.ReverseOrder` annotations correspondingly.

+ `java.util.SortedSet<T>`

+ `java.util.NavigableSet<T>`

+ `java.util.SortedMap<K, V>`

+ `java.util.NavigableMap<K, V>`

Without ordering annotation, ordered sets and maps attributes will be generated as regular attributes to support costruction with custom comparators etc.

When building using builder, collection attributes are addition-only and could be left empty.
You can verify required number of items using [Precondition check method](#check-method)

[Builders](#builder) have special methods to initialize collection attributes:

+ for set or list attribute named `Foo` where elements are of type `T`
  - `addFoo(T)`
  - `addFoo(T...)`
  - `addAllFoo(Iterable<? extends T>)`
  
+ for map attribute named `Bar` where keys are of type `K` and values of type `V`
  - `putBar(K, V)`
  - `putBar(Map.Entry<? extends K, ? extends V>)`
  - `putAllBar(Map<? extends K, ? extends K>)`
  
Since version 0.16 we no longer generate `clear*` methods on builders, so `clearFoo()` or `clearBar()` would not be generated for collection and map attributes. To reset content of collection or map use [copy](#copy-methods) methods right after you build instance.
  
Someone may ask: why other kinds of containers is not supported in the same way,
for example `java.lang.Iterable`, `java.util.Collection` or `java.util.Queue`?
That's because those other containers are either too-generic or too-specific for the purposes of immutable object modelling. This might change upon request, of course (and that is what happened with ordered sets and maps which got some support).
The nice side of this is that any type is supported as attribute value, and while there's no any kind of magic support, other container types are still usable:

```java
@Value.Immutable
public abstract class DoItYourselfContainer {
   public abstract Iterable<String> iterable();
}
...
ImmutableDoItYourselfContainer.builder()
    .iterable(ImmutableSet.of("a", "b", "c"))
    .build();
```

<a name="optional"></a>
### Optional attributes

Attributes declared with return type of `com.google.common.base.Optional<T>`
defines logically [optional](https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained#Optional)
attribute of type `T`. 

Optional value could be omitted when building object, and will default to `Optional.absent()`.
Generated builders have special initializer for optional attributes:

+ for optional attribute named `opt` where elements are of type `T`
  - `opt(T)` sets present value for T
  - `opt(Optional<T>)` specifies present or absent

<a name="default-attribute"></a>
### Default attributes

We could allow attribute to have some default value if it was omitted with [builder](#builder).
To declare default attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.value.Value.Default`. If value was omitted during construction, this initializer method will be called to
retrieve default value of the attribute and store. Consequently, accessor method will return stored value.

```java
@Value.Immutable
public abstract class PlayerInfo {

  @Value.Parameter
  public abstract long id();
  
  @Value.Default
  public String name() {
    return "Anonymous_" + id(); 
  }
  
  @Value.Default
  public int gamesPlayed() {
    return 0; 
  }
}
...

PlayerInfo veteran = ImmutablePlayerInfo.builder()
    .id(1)
    .name("Fiddler")
    .gamesPlayed(99)
    .build();

PlayerInfo anonymous44 = ImmutablePlayerInfo.of(44);

String name = anonymous44.name(); // Anonymous_44
```
Default attribute method's body should not refer to any other derived or default attribute.
Otherwise construction will be broken due to unspecified initialization order.
It's only guaranteed that all attributes with abstract accessors will be initialized before
default and derived attributes, and therefore could be safely referred in initializers.

For immutable [annotation](#annotations) types default attributes defined by using `default` keyword and will have corresponding default constant value initialized if not set.

**Possible problems**

+ Unspecified result if initializer method body refers to non-abstract attribute accessor.

<a name="derived-attribute"></a>
### Derived attributes
Derived attributes may be read from immutable instance, but it could not be set. It's value is usually derived
from other attributes.

To declare derived attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.value.Value.Derived`. Similarly to [default attributes](#default-attribute),
body of the method should compute and return value of an attribute. Derived attributes acts much like
regular methods that simply compute and return some value, but with single important difference:
value of derived attribute computed once and stored to a field (in the end of object construction).

```java
@Value.Immutable
public abstract class Order {

  public abstract List<Item> items();

  @Value.Derived
  public int totalCount() {
    int count = 0;

    for (Item i : items())
      count += i.count();
      
    return count;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11))
    .addItems(Item.of("item2", 22))
    .build();

// total count will be already computed
int totalCount33 = order.totalCount();
```

As with [default attributes](#default-attribute), derived attribute method's
body should not refer to any other derived or default attribute.

**Possible problems**

+ Unspecified result if initializer method body refers to non-abstract attribute accessor. 

<a name="lazy-attribute"></a>
### Lazy attributes
Lazy attributes are initializer methods that computes value lazily once.

To declare lazy attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.value.Value.Lazy`. Similarly to [derived attributes](#derived-attribute),
body of the method should compute and return value of an attribute.
Derived attributes acts much like regular methods, but compute value on first access and subsequently return the same memoized value.

**Be warned**: _lazy attributes do not take part in equals and hashCode computation!_ and act
as [auxiliary](#auxiliary)

```java
@Value.Immutable
public abstract class Order {

  public abstract List<Item> items();

  @Value.Lazy
  public int totalCost() {
    int cost = 0;

    for (Item i : items())
      cost += i.count() * i.price();

    return cost;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11, 1))
    .addItems(Item.of("item2", 22, 2))
    .build();

// total cost will be computed now
int lazilyComputedCost = order.totalCost();
// total cost already computed and stored
lazilyComputedCost = order.totalCost();
```

Lazy values are thread safe and will be computed once and only once regardless of race condition.

Unlike to [default](#default-attribute) or [derived](#derived-attributes) attributes,
body of the lazy attribute accessor method could refer to any attribute.

That said, restrictions still apply to call only abstract accessors from default or derived attributes.
Do not refer to lazy values from default or derived attributes to avoid issues.
Calling lazy attribute from derived or default is _not always safe_,
it will make no sense as it will made lazy value an eagerly computed, moreover, if lazy value is in turn uses in computation one of those default or derived attribute, then it may found it uninitialized.

Implementation of lazy attributes is very similar to the way they implemented in older scala version. Currently this implementation strategy potentially suffers from the problem described in [Scala SIP-20](http://docs.scala-lang.org/sips/pending/improved-lazy-val-initialization.html).
On the other hand, problem could only happen if you are mixing immutable objects with mutable/static/thread-local state: cyclic dependency need to be introduced between different immutable objects.

<a name="check-method"></a>
### Precondition check method
One of the core advantages of immutable objects is the fact that an immutable object will be constructed with proper attribute values in _consistent state_ and _never changes_ afterwards.
So often arises a need to check attribute values or combination of attribute values (cross validation) for correctness.

Given there's no hand-written constructor in a immutable implementation class,
you can write `protected` method annotated with `@Value.Check` and throw runtime exceptions if precondition failed.

```java
@Value.Immutable
public abstract class NumberContainer {
  public abstract List<Number> nonEmptyNumbers();
  
  @Value.Check
  protected void check() {
    Preconditions.checkState(!nonEmptyNumbers().isEmpty(),
        "'nonEmptyNumbers' should have at least one number");
  }
}
...
// will throw IllegalStateException("'nonEmptyNumbers' should have at least one number")
ImmutableNumberContainer.builder().build();
```

However, one should notice how this differs from other kinds of object state validation
where object may be constructed with some values and later validated for correctness
regarding business rules in some context. Precondition checking should not be used to validate against such rules,
but to preserve consistency and guarantee that instances will be usable.

Precondition check methods runs when immutable object _instantiated and all attributes are initialized_,
but _before returned to caller_. Any instance that failed precondition
check is unreachable to caller due to runtime exception.

<a name="copy-methods"></a>
### Copy methods

`with*` methods (withers) allow to change attributes by copying immutable object with new value applied and rest of attributes unchanged.

```java
counter = counter.withValue(counter.value() + 1)
```

Cheap refrence equality `==` check added to prevent copy of the same value by returning `this`. Also primitives has the same `==` value check (except for `float` and `double`). Full equality check or other specialized checks considered were omitted to be too heavy and might be expensive on it's own.

Copy methods provide form of copying with structural sharing. It is very useful to change some of the attributes values, but have other collection attributes reference the same immutable value as before, instead of being rebuilt manually or by builder. New values will effectively share subgraphs of old values, which is desirable in many cases. 

What about collection and map attributes? While it is tempting to have a bunch of methods like `withItemAdded` or `withKeyValuePut`, they might require a lot of variation like _add last_ or _add first_ and will hide the fact of collection rebuilding or rehashing, which is not always desirable for immutable collections. As of now, there's only simple value replacement for all kinds of attributes, but new collection values are guaranteed to be copied as immutable if they are not already.

One of the frequently asked questions among developers using recent versions of _Immutables_: how do I reset collection content while copying object by builder, `clear*` methods were removed from builders some time ago.

* First of all, in any case that is more complex than the simplest ones, you should manually reconstruct collections.
* Conside using `with*` methods to replace copied collection with other values


```java
Value changedValue =
    ImmutableValue.copyOf(existingValue)
        .withName("Changed Name")
        .withValues(ImmutableList.of("Only new value")) // replacing any copied collection
```

Copy methods are generated by default and to use them you need get reference to immutable implementation class instance, rather than up-casted abstract value type reference.
Use `@Value.Immutable(copy = false)` annotation parameter to _disable_ generation of copy methods.

### Singleton instances

It is easy to create "empty" or "default" instances that will be singletons.
Use `@Value.Immutable(singleton = true)` annotation parameter to generate singleton instances, use concise `of()` factory method to obtain singleton instance.

```java
@Value.Immutable(singleton = true)
public abstract class Data {
  public abstract Set<String> chunks();
}

...
boolean willBeTrue =
    ImmuableData.of() == ImmuableData.of();
// true

boolean willBeTrueAlso =
    ImmuableData.of().chunks().isEmpty();
// true
```

Abstract value type should not have any mandatory attributes, otherwise generation of singletons will not be possible.
You can make attributes non-mandatory by using [default attributes](#default-attribute).

As it stands, empty singleton instances could be combined with builders and constructors as long
as all attributes are non-mandatory. But if there should be one
and _only one_ instance of particular immutable type, following recipe will do:

+ Use `singleton = true` and `builder = false` with `@Value.Immutable` annotation
+ Do not use any `@Value.Parameter` on attributes 

```java
@Value.Immutable(singleton = true, builder = false)
public abstract class Singleton {
  // Limit constructor accessibility to a package if needed
  Singleton() {}
}

...
Singleton singleInstance = ImmutableSingleton.of();
```

**Possible problems**

+ If abstract value type contains mandatory attributes
  - Compilation error: could not generate default value for mandatory field.

<a name="interning"></a>
### Instance interning
There are cases when number of values of certain type expected to be finite and
measurable performance improvements may be gained by interning those instances.

If all you need is to _strongly_ intern all instances of particular value type — _Immutables_ just does that for you.
Use `@Value.Immutable(intern = true)` annotation parameter to enable strong interning:

+ Any object returned by builder or constructor will be interned and "canonical" instance returned 
+ `equals` will be short-circuited to object reference equality.

There's support only for strong interning:
soft-reference and weak-reference interning as well as any forms of partial range interning were left out
to be implemented externally.

<a name="prehashed"></a>
### Precomputed hashCode
If immutable object have a lot of attributes or attributes may contain reasonably large
object graphs, then it may become inefficient to recompute `hashCode` value again and again
when used extensively with hashtables.
For such cases, hash code may be precomputed on construction and stored for fast retrieval.
Just use `@Value.Immutable(prehash = true)` annotation parameter to enable hash computing in advance.

### Customize toString, hashCode and equals
It's quite easy to customize generated `toString`, `hashCode` and `equals` methods,
in fact it is as easy as just implement them yourself in abstract value class.
_Immutables_ processor will not override such manual methods with generated ones. 

```java
@Value.Immutable
public abstract class OmniValue {

  @Override
  public boolean equals(Object object) {
    return object instanceof OmniValue;
  }
  
  @Override
  public int hashCode() {
    return 1;
  }

  @Override
  public String toString() {
    return "OmniValue{*}";
  }
}

boolean willBeTrue =
    ImmutableOmniValue.builder().build()
        .equals(new OmniValue() {});
```

Pleasant thing to note is that such manually written `equals` and `hashCode` methods will work
fine with [instance interning](#interning) and [precomputed hashCode](#prehashed) features!

It is deemed to be redundantly to note, but you should implement `equals`
and `hashCode` correctly and only if you a know what you are doing.

<a name="annotations"></a>
### Immutable Annotation
Annotations types could also be annotated as `@Value.Immutable`, immutable annotation implementation will be generated, which behave accordingly to the specification. You could expect array and [default attributes](#default-attribute) and all other features will work as for regular immutable objects.

```java
@Value.Immutable
public @inteface MyAnnotation {
  String[] value();
  boolean enable() default true;
}
...
ImmutableMyAnnotation.builder()
  .addValue("a", "b")
  .enable(true)
  .build();
```

If annotations reside in different library or package, you still can generate implementation and builder using [Include](#include) annotation.

<a name="nesting"></a>
### Flexible nesting
When model messages and documents, you usually want to have a lot of small value classes in one file. In Java this naturally accomplished by nesting those classes under umbrella top level class, and we need to be able to generate immutable subclasses for nested static inner classes or interfaces.

Use `@Value.Nested` annotation on top level class to provide namespacing for implementation classes, generated out of nested abstract value types. This could be used as a matter of style or to avoid name clashes of immutable implementation classes which otherwise would be generated as top level classes in the same package.

* Namespaced implementation have simple names without prefixes
* Could be star-imported for clutter-free usage.

```java
@Value.Nested
class GraphPrimitives {
  @Value.Immutable
  interface Vertex {}
  @Value.Immutable
  static class Edge {}
}
...
import ...ImmutableGraphPrimitives.*;
...
Edge.builder().build();
Vertex.builder().build();
```

<a name="auxiliary"></a>
### Auxiliary attributes
There's annotation that excludes annotated attribute from generated `equals`, `hashCode` and `toString` methods.

`@Value.Auxiliary` attributes will be stored and will be accessible, but are excluded from `equals`, `hashCode` and `toString` method implementations. [Lazy](#lazy-attribute) attributes are always act as _auxiliary_.

```java
@Value.Immutable(intern = true)
interface TypeDescriptor {
  // Instances are interned only by qualified name
  String qualifiedName();
  @Value.Auxiliary
  TypeElement element();
} 
```

--------
Patterns
--------
This section contains common patterns and recipes using _Immutables_
that are useful but not actually features by themselves.

### Expressive factory methods
There were some feature requests to customize names of constructor method and, in addition, provide construction hooks.
We focused on two interconnected needs:

+ Construct object with some values that are different than factory method parameters, but derived from those parameters.
+ Give descriptive name to factory method to highlight how parameters will be used to construct object.

Having considered special annotation parameters and hook-methods,
we eventually came up with... nothing. This, surprisingly, solves the problem and requires no features: simply declare factory methods
on abstract value class and forward calls to constructor method of immutable implementation class.

```java
@Value.Immutable
public abstract class Point {
  @Value.Parameter
  public abstract double x();
  @Value.Parameter
  public abstract double y();
  
  public static Point origin() {
    return ImmutablePoint.of(0, 0);
  }
  
  public static Point of(double x, double y) {
    return ImmutablePoint.of(x, y);
  }
  
  public static Point fromPolar(double r, double t) {
    return ImmutablePoint.of(r * Math.cos(t), r * Math.sin(t));
  }
}
```

You may also want to use forwarding factory method to hide implementation class from a surface of abstract value type API. In example above, notice how usage of `ImmutablePoint` is not leaking through `Point`'s public interface.

<a name="hide-implementation">
It's also possible to hide generated builder implementation in the same manner using nested abstract [Builder](#builder). While it adds up to verbosity, but implementation is not exposed as an API:

```java
@Value.Immutable
public abstract class Point {
  @Value.Parameter
  public abstract double x();
  @Value.Parameter
  public abstract double y();

  public static Point of(double x, double y) {
    return ImmutablePoint.of(x, y);
  }

  public static Builder builder() {
    return ImmutablePoint.builder();
  }
  // Signatures of abstract methods should match to be overriden by implementation
  public abstract static class Builder {
    public abstract Builder x(double x);
    public abstract Builder y(double y);
    public abstract Point build();
  }
}
```


<a name="smart-data"></a>
### Smart data
Immutable objects acts very well in role of a "smart data": in addition to pure data container, value also carries
domain specific knowledge and computation capability. While services and entities orchestrate execution of business logic,
value objects handle computations that are specific to problem domain, but agnostic to business context.

```java
@Value.Immutable
public abstract class OriginDestination {
  @Value.Parameter
  public abstract Airport origin();
  @Value.Parameter
  public abstract Airport destination();

  public boolean isDomestic() {
    return origin().country().equals(destination().country());
  }
  
  public boolean isCrossCityTransit() {
    return origin().city().equals(destination().city());
  }
  
  public OriginDestination reverse() {
    return ImmutableOriginDestination.of(destination(), origin());
  }
  ...
}
```
Go ahead! Enrich value objects with methods that compute values — push computation complexity to the right place!

### Non-public attributes
Particular attributes may become redundant from standpoint of public interface of abstract value class, lowering visibility may help to hide attribute from API consumers, however it is still be exposed as `public` on builders and as constructor parameters.

```java
@Value.Immutable
public abstract class Name {
  @Value.Parameter
  abstract String value(); 
  
  public String toString() {
    return value();
  }
  
  public static Name of(String value) {
    return ImmutableName.of(value);
  }
}
...

Name name = Name.of("The Rose");
String value = name.toString();
// "The Rose"
```

### Null-Object pattern in attribute values
As an alternative to using `Optional<T>` attributes — [null-object pattern](http://en.wikipedia.org/wiki/Null_Object_pattern) could be used.
This requires nothing special from _Immutables_, just use [default attributes](#default-attribute)

```java
public enum Stars {
  NONE, ONE, TWO, THREE, FOUR, FIVE;
}

@Value.Immutable
public abstract class Hotel {
  @Value.Default
  public Stars stars() {
    return Stars.NONE;
  }
}
```

### Opaque containers
When we need to hide some fields in `toString` in hidden manner, or to handle `hasCode` or `equals` in a very specific manner, it's always better to get away without ad-hoc features in annotation processor. For example, if you want to mask some confidential data from `toString` method create opaque wrapper for this data, most often you will need it anyway.

```java
@Value.Immutable(builder = false)
abstract class Confidential {
  @Value.Parameter
  abstract String value();
  public String toString() { return "<NON DISCLOSED>"; }
}
```

Then you can have it as an attribute

```java
@Value.Immutable
interface Value {
  int number();
  Confidential confidential();
}
...
// toString
"Value{number=1, confidential=<NON DISCLOSED>}"
```

See also [Auxiliary attributes](#auxiliary)

-----------
Limitations
-----------
Some features are not implemented due to lack of time or interest,
while other features are too complex or too specific — so it's better
to not implement them. Power to weight ratio is always considered!

- Default and derived attributes cannot reliably refer to any other default or derived attribute.
- Abstract value class could not be parameterized with type variables,
  however it could extend or implement parameterized type when actual types supplied.
- _(...)_
