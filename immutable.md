---
title: 'Immutable objects'
layout: page
---

Overview
--------
[Get started!](/getstarted.html) create an _abstract value type and then add annotation to generate _immutable implementation class_!

See [sample generated code](/generated.html) for an example of what kind of code is being generated by the processor.

Read boring [Introduction](/intro.html).

Or jump straight to the [features](#features) implemented!

--------
Concepts
--------

<a name="abstract-value"></a>
### Abstract value type
Abstract value type — manually written non-final (usually abstract) class or interface (or even annotation type) that defines value type and is annotated with `org.immutable.value.Value.Immutable` annotation. May contain [attributes](#attributes) and other meta-data, as well as regular java methods (and fields if needed). It is strongly recommended to not introduce visible mutable state in abstract value class. Abstract value types are used as the source model for generated code. [Get started!](/getstarted.html).

<a name="attributes"></a>
### Attributes
An attribute hold value which cannot be changed after object is created.
It is intentionally named "attribute" to distinguish it from "field" and JavaBean "property" and also to draw similarity with annotation attributes. It is defined by accessor method: zero argument, non-`void` java method.
No annotation required on abstract accessor method to became attribute, however some attributes,
such as attributes with [default values](#default-attribute)
are non-`abstract` methods that have body that computes value,
thus such accessors require special annotation to distinguish from regular method.

### Immutable implementation class
[Generated](/generated.html) `final class` that extends manually-written [abstract value type](#abstract-value)
and implements all declared accessor methods as well as supporting fields, methods, constructors and builder class.
Immutable implementation class implements abstract attribute accessors
for scalar primitive and object reference types, special support provided for [collection attributes](#collection)
and some other types.
`Object`'s methods `equals`, `hashCode` and `toString` are overridden and fully dependent on attribute values
rather that object identity.
Immutable implementation class is primary, but not the only source code artifact
generated by _Immutables_ annotation processor.

<a name="features"></a>
--------
Features
--------

### Value
The annotation processor works by using annotated abstract value types as a model to generate immutable implementation, which extends or implements abstract value type. Classes don't have to be abstract if they are not defining abstract accessor methods. 

```java
@Value.Immutable
interface ValueInterface {}

@Value.Immutable
class ValueClass {}

@Value.Immutable
@interface ValueAnnotation {}

...

ValueInterface valueInterface = ImmutableValueInterface.builder().build();

ValueClass valueClass = ImmutableValueClass.builder().build();

ValueAnnotation valueAnnotation = ImmutableValueAnnotation.builder().build();
```
_You can customize class names to have other prefixes than `Immutable*` or don't have prefix at all, see [styles](/style.html)_.

Abstract value types might be nested inside other types, classes should be `static` if declared as inner class (interfaces and annotations are implicitly static if nested).

But you are not limited to classes that you control. You can generate immutable implementation classes from the abstract types in other packages. `@Value.Include()` annotation could be used on types and packages. This is most usefull when you want to generate implementation of annotations to use with DI libraries like _Guice_. Inclusion could be used in combination with [`@Value.Enclosing`](/style.html#nesting)

```java
package my.package;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import org.immutables.value.Value;

@Value.Include({ Retention.class })
interface Annotations {
}
...

ImmutableRetention.build()
    .value(RetentionPolicy.CLASS);
    .build();
```

<a name="builder"></a>
### Builder
By default, builders are generated for each immutable implementation class.
Builders enable expressive construction of object using named attribute initializers,
and generally builders compensates lack of named and optional constructor arguments in Java language.

+ To create builder invoke static `builder()` method on generated immutable implementation class
+ Invoke attribute initializer methods to set attributes
+ Call `build()` methods to construct immutable instance after attributes are initialized.

Build method will fail if any mandatory attribute is omitted. Efficient bit masks are used to track which attributes are initialized!

```java
// builder methods illustrated
ImmutableValue.builder()
    .foo(1442)
    .bar(true)
    .addBuz("a")
    .addBuz("1", "2")
    .addAllBuz(iterable)
    .putQux(key, value)
    .build();
```

_You can customize initialization method to have prefixes like `set` or `with`, have builder created by constructor, have `create` method etc. See [styles](/style.html)_.

By default builder will have method `from`, which allow to copy-edit operations on immutable values. This could be used to prevent structural sharing as with [copy-methods](#copy-methods) or to accumulate collection elements from attributes of multiple values.

```java

ImmutableValue.builder()
    .from(otherValue) // merges attrbiute value into builder
    .addBuz("b")
    .build();
```

`from` method on builder is much more sound and powerful alternative than having `toBuilder()` (or alike) on immutable value.
In old versions of _Immutables_ (0.16 and below) this method was called `copy`. (Of course, now you can customize name of this method). `from` method is not generated in a [strict builder](#strict-builder) mode.

If builder became redundant in presence of [constructor](#constructor), you can disable generation of builder using `@Value.Immutable(builder = false)` annotation parameter.

In advanced usage of builders you will want to pass builders that builds different types of objects but conform to the
same interface, akin to original [Builder pattern](http://en.wikipedia.org/wiki/Builder_pattern).
It is archivable by declaring static nested class named "Builder",
which will be extended by generated builder.

```java
interface Vehicle {
}

interface VehicleBuilder {
  // Generated builders will implement this method
  // It is compatible with signature of generated builder methods where
  // return type is narrowed to Scooter or Automobile
  Vehicle build();
}

@Value.Immutable
public abstract class Scooter implements Vehicle {
  public abstract static class Builder implements VehicleBuilder {}
}

@Value.Immutable
public abstract class Automobile implements Vehicle {
  public abstract static class Builder implements VehicleBuilder {}
}

class Builders {
  void buildIt(VehicleBuilder builder) {
    Vehicle vehicle = builder.build();
  }
  
  void use() {
    buildIt(ImmutableScooter.builder());
    buildIt(ImmutableAutomobile.builder());
  }
}
```

Explicitly declared abstract "Builder" could specify all needed `extends` or `implements` declarations as well as it could have convenience methods that will show up on immutable object builder. However, special care should be taken in order to maintain structural compatibility of
declared builder supertype and generated builders, otherwise compile error will occur in generated code.

Using "forwarding" factory methods and abstract builder it is possible to hide generated implementation type and it's builder from the API. See [example](#hide-implementation).

<a name="strict-builder"></a>
### Strict Builder
By setting special style "strictBuilder" (`@Value.Style(strictBuilder = true, ...)`) you can turn generated builder to operate in a strict mode: only forward-only initilization is possible. I.e. only additive operations are available on collection attributes and regular attributes could be set only once. Strict mode is off by default: regular builders are generated in a way that allow to reset previously set values, and this is ok for many usages. On the other hand, strict builders enable early error detection during initialization like misspellings or copy-paste leftovers. This makes builders even more similar to object literals expressions.

```java
@Value.Immutable
@Value.Style(strictBuilder = true)
interface Aar {
  boolean a();
  Integer b();
}

ImmutableAar.builder()
    .a(true)
    .b(1)
    .b(2) // IllegalStateException will be thrown here, 'b' cannot be reinitialized
    .build();
```

No methods to reset collection are generated on strict builder, as well, there's no `from` method generated on strict builder. Those methods are error-inducing APIs in strict mode.

Note that it is not recommended to use `@Value.Style` directly on abstract value type, use it directly only for experimentations. Better way is to create meta-annotations for styling as described in [style guide](/style.html).

<a name="constructor"></a>
### Constructor method
As an alternative to builder, it is possible to provide concise "constructor" factory method.
Constructor will be available as `static` method named `of` on immutable implementation class.

In order to generate constructor method, certain attributes should be annotated
with `org.immutables.value.Value.Parameter` annotation.

```java
@Value.Immutable
public abstract class HostWithPort {
  @Value.Parameter
  public abstract String hostname();
  @Value.Parameter
  public abstract int port();
}
...
HostWithPort hostWithPort = ImmutableHostWithPort.of("localhost", 8081);

boolean willBeTrue = hostWithPort.equals(
    ImmutableHostWithPort.builder()
        .hostname("localhost")
        .port(8081)
        .build());
```

If there's more that one constructor parameter it is advised to put `order` annotation attribute to make constructor parameter order deterministic across java compilers that may not honor source order. Source ordering currently works for Javac and Eclipse JDT compilers.

**Things to be aware of**

+ If not all mandatory attributes are marked as `@Value.Parameter`
  - Compilation error: could not generate default value for mandatory field.

<a name="collection"></a>
### Array, Collection and Map attributes

Following collection types enjoy built-in support for convenient usage:

+ `T[]`

+ `java.util.List<T>`

+ `java.util.Set<T>`

+ `java.util.Map<K, V>`

+ `com.google.common.collect.Multiset<T>`

+ `com.google.common.collect.Multimap<K, V>` (`ListMultimap`, `SetMultimap`)

Array attributes are being cloned for safety.
Collection attributes are backed by Guava immutable collections if Guava is available in classpath, or are safely copied and wrapped in unmodifiable collection classes from standard JDK,
moreover, `java.util.Set` and `java.util.Map` with `enum` keys
are backed by efficient `EnumSet` and `EnumMap` implementations.

In addition, ordered maps and sets are supported for natural and reverse natural ordering
using `@Value.NaturalOrder` and `@Value.ReverseOrder` annotations correspondingly.

+ `java.util.SortedSet<T>`

+ `java.util.NavigableSet<T>`

+ `java.util.SortedMap<K, V>`

+ `java.util.NavigableMap<K, V>`

Without ordering annotation, ordered sets and maps attributes will be generated as regular attributes to support costruction with custom comparators etc.

When building using builder, collection attributes could be left unspecified.
You can verify required number of items using [Precondition check method](#check-method)

[Builders](#builder) have special methods to initialize collection attributes:

+ for array attribute named `foo` where elements are of type `T`
  - `foo(T...)`

+ for list, set or multiset attribute named `foo` where elements are of type `T`
  - `foo(Iterable<? extends T>)` &mdash; not available in [strict](#strict-builder) mode
  - `addFoo(T)`
  - `addFoo(T...)`
  - `addAllFoo(Iterable<? extends T>)`
  
+ for map attribute named `bar` where keys are of type `K` and values of type `V`
  - `bar(Map<? extends K, ? extends K>)` &mdash; not available in [strict](#strict-builder) mode
  - `putBar(K, V)`
  - `putBar(Map.Entry<? extends K, ? extends V>)`
  - `putAllBar(Map<? extends K, ? extends K>)`

+ for multimap attribute named `bar`
  - `bar(Multimap<? extends K, ? extends K>)` &mdash; not available in [strict](#strict-builder) mode
  - `putBar(K, V)`
  - `putBar(Map.Entry<? extends K, ? extends V>)`
  - `putBar(K, ...V)`
  - `putAllBar(K, Iterable<V>)`
  - `putAllBar(Multimap<? extends K, ? extends K>)`
  
Since version 0.16 we no longer generate `clear*` methods on builders, so `clearFoo()` or `clearBar()` would not be generated for collection and map attributes. To clear content of collection or map. Use reset method like `bar(Collections.emptyList())` or use [copy methods](#copy-methods) right after instance is built.

The set of methods was choosen to be minimal for a convenient usage. Smaller set of methods resulted in noisy conversions all over the code. Bigger set of methods resulted in kitchen sink
(duplicating mutable collection API?).
If concerned with the number of methods, consider using tools like _ProGuard_ to remove unused generated methods.

Why other kinds of containers is not supported in the same way,
for example `java.lang.Iterable`, `java.util.Collection` or `java.util.Queue`?
That's because those other containers are either too-generic or too-specific for the purposes of immutable object modelling. This might change upon request, of course (and that is what happened with ordered sets and maps which got some support).
The nice side of this is that any type is supported as attribute value, and while there's no any kind of magic support, other container types are still usable:

```java
@Value.Immutable
public abstract class DoItYourselfContainer {
   public abstract Iterable<String> iterable();
}
...
ImmutableDoItYourselfContainer.builder()
    .iterable(ImmutableSet.of("a", "b", "c"))
    .build();
```

<a name="optional"></a>
### Optional attributes

Attributes declared with return type of `com.google.common.base.Optional<T>`
defines logically [optional](https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained#Optional)
attribute of type `T`.

As of 2.0, `java.util.Optional`, `java.util.OptionalInt`, `java.util.OptionalLong`, `java.util.OptionalDouble` from Java 8 are fully supported also.

Optional value could be omitted when building object, and will default to `Optional.absent()` (or `Optional.empty()`).
Generated builders have special initializer for optional attributes:

+ for optional attribute named `opt` where elements are of type `T`
  - `opt(T)` sets present value for T
  - `opt(Optional<T>)` specifies present or absent

```java
import java.util.*;

@Value.Immutable
public interface AllOptional {
  com.google.common.base.Optional<Integer> v1();
  Optional<Integer> v2();
  OptionalInt i1();
  OptionalLong l1();
  OptionalDouble d1();
}
...
// No error as all values are optional
ImmutableAllOptional.builder().build();

ImmutableAllOptional.builder()
    .v1(1)
    .v2(2)
    .i1(1)
    .l1(1L)
    .d1(1.0)
    .build();
```

<a name="default-attribute"></a>
### Default attributes

We could allow attribute to have some default value if it was omitted with [builder](#builder).
To declare default attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.value.Value.Default`. If value was omitted during construction, this initializer method will be called to
retrieve default value of the attribute and store. Consequently, accessor method will return stored value.

```java
@Value.Immutable
public abstract class PlayerInfo {

  @Value.Parameter
  public abstract long id();
  
  @Value.Default
  public String name() {
    return "Anonymous_" + id(); 
  }
  
  @Value.Default
  public int gamesPlayed() {
    return 0; 
  }
}
...

PlayerInfo veteran = ImmutablePlayerInfo.builder()
    .id(1)
    .name("Fiddler")
    .gamesPlayed(99)
    .build();

PlayerInfo anonymous44 = ImmutablePlayerInfo.of(44);

String name = anonymous44.name(); // Anonymous_44
```
Default attribute method's body should not refer to any other derived or default attribute.
Otherwise construction will be broken due to unspecified initialization order.
It's only guaranteed that all attributes with abstract accessors will be initialized before
default and derived attributes, and therefore could be safely referred in initializers.

For immutable [annotation](#annotations) types default attributes defined by using `default` keyword and will have corresponding default constant value initialized if not set.

**Things to be aware of**

+ Unspecified result if initializer method body refers to non-abstract attribute accessor.

<a name="derived-attribute"></a>
### Derived attributes
Derived attributes may be read from immutable instance, but it could not be set. It's value is usually derived
from other attributes.

To declare derived attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.value.Value.Derived`. Similarly to [default attributes](#default-attribute),
body of the method should compute and return value of an attribute. Derived attributes acts much like
regular methods that simply compute and return some value, but with single important difference:
value of derived attribute computed once and stored to a field (in the end of object construction).

```java
@Value.Immutable
public abstract class Order {

  public abstract List<Item> items();

  @Value.Derived
  public int totalCount() {
    int count = 0;

    for (Item i : items())
      count += i.count();
      
    return count;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11))
    .addItems(Item.of("item2", 22))
    .build();

// total count will be already computed
int totalCount33 = order.totalCount();
```

As with [default attributes](#default-attribute), derived attribute method's
body should not refer to any other derived or default attribute.

**Things to be aware of**

+ Unspecified result if initializer method body refers to non-abstract attribute accessor. 

<a name="nullable"></a>
### Nullable attributes
We would recommend against using nullable attributes, but if you really need it, add `@Nullable` annotation to the abstract attribute accessor. Any annotation with simple name `Nullable` will work. Nullable attributes are not required to be set using builder, and even `null` value could be used to initialize it. Nullable collections and other special types are not supported, more precisely, adding `@Nullable` turns it into "nothing-special" attribute.

```java
@Value.Immutable
interface NullAccepted {
  @Nullable Integer i1();
  @Nullable Long l2();
}

NullAccepted obj = ImmutableNullAccepted.builder()
    .i1(null)
    .build();

obj.toString(); // NullAccepted{i1=null, l2=null}    
```

<a name="lazy-attribute"></a>
### Lazy attributes
Lazy attributes are initializer methods that computes value lazily once.

To declare lazy attribute, create non-abstract attribute initializer method and annotate it with
`org.immutables.value.Value.Lazy`. Similarly to [derived attributes](#derived-attribute),
body of the method should compute and return value of an attribute.
Derived attributes acts much like regular methods, but compute value on first access and subsequently return the same memoized value.

**Things to be aware of**

+ lazy attributes do not take part in equals and hashCode computation! and act as [auxiliary](#auxiliary)

```java
@Value.Immutable
public abstract class Order {

  public abstract List<Item> items();

  @Value.Lazy
  public int totalCost() {
    int cost = 0;

    for (Item i : items())
      cost += i.count() * i.price();

    return cost;
  }
}

Order order = ImmutableOrder.builder()
    .addItems(Item.of("item1", 11, 1))
    .addItems(Item.of("item2", 22, 2))
    .build();

// total cost will be computed now
int lazilyComputedCost = order.totalCost();
// total cost already computed and stored value is returned
lazilyComputedCost = order.totalCost();
```

Lazy values are thread safe and will be computed once and only once regardless of race condition.

Unlike to [default](#default-attribute) or [derived](#derived-attributes) attributes,
body of the lazy attribute accessor method could refer to any attribute.

That said, restrictions still apply to call only abstract accessors from default or derived attributes.
Do not refer to lazy values from default or derived attributes to avoid issues.
Calling lazy attribute from derived or default is _not always safe_,
it will make no sense as it will made lazy value an eagerly computed, moreover, if lazy value is in turn uses in computation one of those default or derived attribute, then it may found it uninitialized.

Implementation of lazy attributes is very similar to the way they implemented in older scala version. Currently this implementation strategy potentially suffers from the problem described in [Scala SIP-20](http://docs.scala-lang.org/sips/pending/improved-lazy-val-initialization.html).
On the other hand, problem could only happen if you are mixing immutable objects with mutable/static/thread-local state: cyclic dependency need to be introduced between different immutable objects.

<a name="check-method"></a>
### Precondition check method
One of the core advantages of immutable objects is the fact that an immutable object will be constructed with proper attribute values in _consistent state_ and _never changes_ afterwards.
So often arises a need to check attribute values or combination of attribute values (cross validation) for correctness.

Given there's no hand-written constructor in a immutable implementation class,
you can write `protected` method annotated with `@Value.Check` and throw runtime exceptions if precondition failed.

```java
@Value.Immutable
public abstract class NumberContainer {
  public abstract List<Number> nonEmptyNumbers();
  
  @Value.Check
  protected void check() {
    Preconditions.checkState(!nonEmptyNumbers().isEmpty(),
        "'nonEmptyNumbers' should have at least one number");
  }
}
...
// will throw IllegalStateException("'nonEmptyNumbers' should have at least one number")
ImmutableNumberContainer.builder().build();
```

However, one should notice how this differs from other kinds of object state validation
where object may be constructed with some values and later validated for correctness
regarding business rules in some context. Precondition checking should not be used to validate against such rules,
but to preserve consistency and guarantee that instances will be usable.

Precondition check methods runs when immutable object _instantiated and all attributes are initialized_, but _before returned to a caller_. Any instance that failed precondition
check is unreachable to a caller due to runtime exception.

<a name="copy-methods"></a>
### Copy methods

`with*` methods (withers) allow to change attributes by copying immutable object with new value applied and rest of attributes unchanged.

```java
counter = counter.withValue(counter.value() + 1)
```

Cheap refrence equality `==` check added to prevent copy of the same value by returning `this`. Also primitives has the same `==` value check (except for `float` and `double`). Full equality check or other specialized checks considered were omitted to be too heavy and might be expensive on it's own.

Copy methods provide form of copying with structural sharing. It is very useful to change some of the attributes values, but have other collection attributes reference the same immutable value as before, instead of being rebuilt manually or by builder. New values will effectively share subgraphs of old values, which is desirable in many cases. 

What about collection and map attributes? While it is tempting to have a bunch of methods like `withItemAdded` or `withKeyValuePut`, they might require a lot of variation like _add last_ or _add first_ and will hide the fact of collection rebuilding or rehashing, which is not always desirable for immutable collections. As of now, there's only simple value replacement for all kinds of attributes, but new collection values are guaranteed to be copied as immutable if they are not already immutable.

```java
Value changedValue =
    ImmutableValue.copyOf(existingValue)
        .withName("Changed Name")
        .withValues(Arrays.asList("Only new value")) // replacing any copied collection
```

Copy methods are generated by default and to use them you need get reference to immutable implementation class instance, rather than up-casted abstract value type reference.

Use `@Value.Immutable(copy = false)` annotation parameter to _disable_ generation of copy methods.

<a name="singleton"></a>
### Singleton instances

It is easy to create "empty" or "default" instances that will be singletons.
Use `@Value.Immutable(singleton = true)` annotation parameter to generate singleton instances, use concise `of()` factory method to obtain singleton instance.

```java
@Value.Immutable(singleton = true)
public abstract class Data {
  public abstract Set<String> chunks();
}

...
boolean willBeTrue =
    ImmuableData.of() == ImmuableData.of();
// true

boolean willBeTrueAlso =
    ImmuableData.of().chunks().isEmpty();
// true
```

Abstract value type should not have any mandatory attributes, otherwise generation of singletons will not be possible.
You can make attributes non-mandatory by using [default attributes](#default-attribute) or optional.

As it stands, empty singleton instances could be combined with builders and constructors as long
as all attributes are non-mandatory. If you want to provide only singleton instance, disable builder and constuctor:

+ Use `singleton = true` and `builder = false` with `@Value.Immutable` annotation
+ Do not use any `@Value.Parameter` on attributes, so no constuctor generated

```java
@Value.Immutable(singleton = true, builder = false)
public abstract class Singleton {
  // Limit constructor accessibility to a package if needed.
  // Private access will not work as ImmutableSingleton should
  // be able to extend Singleton
  Singleton() {}
}

...
Singleton singleInstance = ImmutableSingleton.of();
```

**Things to be aware of**

+ If abstract value type contains mandatory attributes
  - Compilation error: could not generate default value for mandatory field.

<a name="interning"></a>
### Instance interning
There are cases when number of values of certain type expected to be finite and
measurable performance improvements may be gained by interning those instances.

If all you need is to _strongly_ intern all instances of particular value type — _Immutables_ just does that for you.
Use `@Value.Immutable(intern = true)` annotation parameter to enable strong interning:

+ Any object returned by builder or constructor will be interned and "canonical" instance returned 
+ `equals` will be short-circuited to object reference equality.

There's support only for strong interning:
soft-reference and weak-reference interning as well as any forms of partial range interning were left out to be implemented externally.
However there's module `org.immutables:ordinal` which supports sophisticated domain-based interning of enum-like objects. See javadocs of classes in that module.

<a name="prehashed"></a>
### Precomputed hashCode
If immutable object have a lot of attributes or attributes may contain reasonably large
object graphs, then it may become inefficient to recompute `hashCode` value again and again
when used extensively with hashtables.
For such cases, hash code may be precomputed on construction and stored for fast retrieval.
Just use `@Value.Immutable(prehash = true)` annotation parameter to enable hash computing in advance.

### Customize toString, hashCode and equals
It's quite easy to customize generated `toString`, `hashCode` and `equals` methods,
in fact it is as easy as just implement them yourself in abstract value class.
_Immutables_ processor will not override such manual methods with generated ones. 

```java
@Value.Immutable
public abstract class OmniValue {

  @Override
  public boolean equals(Object object) {
    return object instanceof OmniValue;
  }
  
  @Override
  public int hashCode() {
    return 1;
  }

  @Override
  public String toString() {
    return "OmniValue{*}";
  }
}

boolean willBeTrue =
    ImmutableOmniValue.builder().build()
        .equals(new OmniValue() {});
```

Pleasant thing to note is that such manually written `equals` and `hashCode` methods will work
fine with [instance interning](#interning) and [precomputed hashCode](#prehashed) features!

It is deemed to be redundantly to note, but you should implement `equals`
and `hashCode` correctly and only if you a know what you are doing.

<a name="annotations"></a>
### Immutable Annotation
Annotations types could also be annotated as `@Value.Immutable`, immutable annotation implementation will be generated, which behave accordingly to the specification. You could expect array and [default attributes](#default-attribute) and all other features will work as for regular immutable objects.

```java
@Value.Immutable
public @inteface MyAnnotation {
  String[] value();
  boolean enable() default true;
}
...
ImmutableMyAnnotation.builder()
  .addValue("a", "b")
  .enable(true)
  .build();
```

If annotations reside in different library or package, you still can generate implementation and builder using [Include](#include) annotation.

<a name="auxiliary"></a>
### Auxiliary attributes
There's annotation that excludes annotated attribute from generated `equals`, `hashCode` and `toString` methods.

`@Value.Auxiliary` attributes will be stored and will be accessible, but are excluded from `equals`, `hashCode` and `toString` method implementations. [Lazy](#lazy-attribute) attributes are always act as _auxiliary_.

```java
@Value.Immutable(intern = true)
interface TypeDescriptor {
  // Instances are interned only by qualified name
  String qualifiedName();
  @Value.Auxiliary
  TypeElement element();
}
```

<a name="serialization"></a>
### Serialization

Basic java binary serialization is supported in a following way to:

* Detect if abstract value type implementing `Serializable`
* Make lazy attributes `transient`
* Copy `serialVersionUID` from abstract value type to immutable implementation type
* Generate `readResolve` method implementation to preserve [singleton](#singleton) and [interned](#interning) instances.

For other serialization options see [JSON](/json.html) guide.

<a name="generics"></a>
### Generics (not) supported
_Immutables_ do not support type parameters in the sense that you cannot add type variables to the abstract value type and construct parametrized instances. This is definitely a sort of limitation and probably will be lifted at some point. However this is still not a clear if we should support this, given how much headaches it might bring when implementing various functionality like collection support in builder or [JSON](/html#gson) serialization etc. Annotation processing provide very limited tools to analyse types: if you want to get beyond simplest cases then complex type variable resolution should be programmed, including handing of intersection types, lower and upper bounds etc.

Having that said, there's also some good news: generics are supported by creating abstract value types as instantiations of paramerized types. To not confuse any more, here's example of what's possible with _Immutables_:

```java
// WARNING, THIS EXAMPLE CURRENTLY WORKS ONLY USING ECJ (ECLIPSE) COMPILER
// JAVAC HAVE PROBLEM WITH List<TreeElement<T>>.

interface TreeElement<T> {}

interface Node<T> extends TreeElement<T> {
  List<TreeElement<T>> elements();
}

interface Leaf<T> extends TreeElement<T> {
  @Value.Parameter T value();
}

@Value.Immutable
interface StringNode extends Node<String> {}

@Value.Immutable
interface StringLeaf extends Leaf<String> {}

TreeElement<String> tree =
    ImmutableStringNode.builder()
        .addElements(ImmutableStringLeaf.of("A"))
        .addElements(ImmutableStringLeaf.of("B"))
        .addElements(
            ImmutableStringNode.builder()
                .addElements(ImmutableStringLeaf.of("C"))
                .addElements(ImmutableStringLeaf.of("D"))
                .build())
        .build();
```

You can notice that inherited attributes are being generated with correct type variable substitution. While not perfect it still very useful, and in some cases even better that fully-erased generic types.

--------
Patterns
--------
This section contains common patterns and recipes using _Immutables_
that are useful but not actually features by themselves.

### Expressive factory methods
There were some feature requests to customize names of constructor method and, in addition, provide construction hooks.
We focused on two interconnected needs:

+ Construct object with some values that are different than factory method parameters, but derived from those parameters.
+ Give descriptive name to factory method to highlight how parameters will be used to construct object.

Having considered special annotation parameters and hook-methods,
we eventually came up with... nothing. This, surprisingly, solves the problem and requires no features: simply declare factory methods
on abstract value class and forward calls to constructor method of immutable implementation class.

```java
@Value.Immutable
public abstract class Point {
  @Value.Parameter
  public abstract double x();
  @Value.Parameter
  public abstract double y();
  
  public static Point origin() {
    return ImmutablePoint.of(0, 0);
  }
  
  public static Point of(double x, double y) {
    return ImmutablePoint.of(x, y);
  }
  
  public static Point fromPolar(double r, double t) {
    return ImmutablePoint.of(r * Math.cos(t), r * Math.sin(t));
  }
}
```

You may also want to use forwarding factory method to hide implementation class from a surface of abstract value type API. In example above, notice how usage of `ImmutablePoint` is not leaking through `Point`'s public interface.

<a name="hide-implementation"></a>

It's also possible to hide generated builder implementation in the same manner using nested abstract [Builder](#builder). While it adds up to verbosity, but implementation is not exposed as an API:

```java
@Value.Immutable
public abstract class Point {
  @Value.Parameter
  public abstract double x();
  @Value.Parameter
  public abstract double y();

  public static Point of(double x, double y) {
    return ImmutablePoint.of(x, y);
  }

  public static Builder builder() {
    return ImmutablePoint.builder();
  }
  // Signatures of abstract methods should match to be overriden by implementation
  public abstract static class Builder {
    public abstract Builder x(double x);
    public abstract Builder y(double y);
    public abstract Point build();
  }
}
```


<a name="smart-data"></a>
### Smart data
Immutable objects acts very well in role of a "smart data": in addition to pure data container, value also carries
domain specific knowledge and computation capability. While services and entities orchestrate execution of business logic,
value objects handle computations that are specific to problem domain, but agnostic to business context.

```java
@Value.Immutable
public abstract class OriginDestination {
  @Value.Parameter
  public abstract Airport origin();
  @Value.Parameter
  public abstract Airport destination();

  public boolean isDomestic() {
    return origin().country().equals(destination().country());
  }
  
  public boolean isCrossCityTransit() {
    return origin().city().equals(destination().city());
  }
  
  public OriginDestination reverse() {
    return ImmutableOriginDestination.of(destination(), origin());
  }
  ...
}
```
Go ahead! Enrich value objects with methods that compute values — push computation complexity to the right place!

### Non-public attributes
Particular attributes may become redundant from standpoint of public interface of abstract value class, lowering visibility may help to hide attribute from API consumers, however it is still be exposed as `public` on builders and as constructor parameters.

```java
@Value.Immutable
public abstract class Name {
  @Value.Parameter
  abstract String value(); 
  
  public String toString() {
    return value();
  }
  
  public static Name of(String value) {
    return ImmutableName.of(value);
  }
}
...

Name name = Name.of("The Rose");
String value = name.toString();
// "The Rose"
```

### Null-Object pattern in attribute values
As an alternative to using `Optional<T>` attributes — [null-object pattern](http://en.wikipedia.org/wiki/Null_Object_pattern) could be used.
This requires nothing special from _Immutables_, just use [default attributes](#default-attribute)

```java
public enum Stars {
  NONE, ONE, TWO, THREE, FOUR, FIVE;
}

@Value.Immutable
public abstract class Hotel {
  @Value.Default
  public Stars stars() {
    return Stars.NONE;
  }
}
```

### Opaque containers
When we need to hide some fields in `toString` in hidden manner, or to handle `hasCode` or `equals` in a very specific manner, it's always better to get away without ad-hoc features in annotation processor. For example, if you want to mask some confidential data from `toString` method create opaque wrapper for this data, most often you will need it anyway.

```java
@Value.Immutable(builder = false)
abstract class Confidential {
  @Value.Parameter
  abstract String value();
  public String toString() { return "<NON DISCLOSED>"; }
}
```

Then you can have it as an attribute

```java
@Value.Immutable
interface Value {
  int number();
  Confidential confidential();
}
...
// toString
"Value{number=1, confidential=<NON DISCLOSED>}"
```

See also [Auxiliary attributes](#auxiliary)

-----------
Limitations
-----------
Some features are not implemented due to lack of time or interest,
while other features are too complex or too specific — so it's better
to not implement them. Power to weight ratio is always considered!

- Default and derived attributes cannot reliably refer to any other default or derived attribute.
- Abstract value class could not be parameterized with type variables,
  however it could extend or implement parameterized type when actual types supplied.
- _(...)_
